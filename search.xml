<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java学习(基础篇01)—数组模拟实现栈]]></title>
    <url>%2F1.html</url>
    <content type="text"><![CDATA[栈的概念 ==先进后出==策略(LIFO) 是一种基本数据结构 栈的分类有两种：1.静态栈（数组实现） 2.动态栈（链表实现） 栈的模型图如下： 需求分析在编写代码之前，我习惯先对要实现的程序进行需求分析，比如用什么数据结构存储数据，需要实现哪些基本的功能等。这次是通过数组模拟实现栈，所以是一个==静态栈==，但是我在栈满时通过arraycopy函数自动扩容，后面会细说。 我们要实现的功能至少应该包含以下功能： 123456789101112131415161718192021222324252627282930313233public class Stack &#123; private int[] array;//模拟栈 private int length = 0;//栈总长度 private int size = 0;//栈存在元素个数 public Stack() &#123; this(10); &#125; public Stack(int length) &#123; array = new int[length]; this.length = length; &#125; //入栈 public void push(int num) &#123;&#125; //出栈 public int pop() &#123;&#125; //栈是否为空 public boolean isEmpty() &#123;&#125; //栈是否已满,已满则每次扩容5个单位 public boolean isFull() &#123;&#125; //清除栈所有元素 public void removeAll() &#123;&#125; //获取栈内存在元素个数 public int getSize() &#123;&#125; //获取栈的总长度 public int getLength() &#123;&#125;&#125; 具体实现 入栈push()首先判断当前栈是否已满，如果已满则扩容；此时栈内存在元素size增加1。 123456//入栈public void push(int num) &#123; isFull(); array[length-1-size] = num; size++;&#125; 出栈pop()判断当前栈是否为空，为空则返回0；不为空，将数组中最靠近下标0的非0元素置0；此时栈内元素size减1，并返回出栈的值； 1234567891011121314151617//出栈public int pop() &#123; if(isEmpty()) &#123; return 0; &#125; int result = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i]==0) &#123; continue; &#125; result = array[i]; array[i] = 0; size--; break; &#125; return result;&#125; 栈是否为空isEmpty() 12345678//栈是否为空public boolean isEmpty() &#123; if(size==0) &#123; System.out.println("栈为空！"); return true; &#125; return false;&#125; 栈是否已满,已满则每次扩容5个单位isFull()如果栈内存在的元素个数等于数组长度，则表示栈已满；通过new一个新的更大的数组，调用arraycopy方法将b的引用赋给array，并且数组的长度也要加长。arraycopy()的参数含义如下： 123456789/** * 参数含义 * @param src 原数组对象的引用 * @param srcPos 原数组要拷贝的数据的原始位置 * @param dest 目标数组对象的引用 * @param destPos 目标数组要拷贝的数据的原始位置 * @param length 原数组要拷贝的长度 */ public static native void arraycopy(Object src, int srcPos,Object dest, int destPos, int length); 123456789101112//栈是否已满,已满则每次扩容5个单位public boolean isFull() &#123; if (size==length) &#123; //System.out.println("当前栈已满，扩容5个单位。"); int[] b = new int[length+5]; System.arraycopy(array, 0, b, 5, length); array = b; this.length += 5; return true; &#125; return false;&#125; 清除栈所有元素removeAll()清除所有元素就是遍历一遍数组，将全部元素的值置0； 123456789//清除栈所有元素public void removeAll() &#123; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i]!=0) &#123; array[i] = 0; size--; &#125; &#125;&#125; 获取栈内存在元素个数getSize() 1234//获取栈内存在元素个数public int getSize() &#123; return size;&#125; 获取栈的总长度getLength() 1234//获取栈的总长度public int getLength() &#123; return length;&#125; 测试12345678910111213141516171819202122232425262728public class StackTest &#123; public static void main(String[] args) &#123; //创建一个默认长度为10的栈 Stack stack = new Stack(2); //入栈 stack.push(10); stack.push(9); stack.push(8); System.out.println("当前栈元素个数:"+stack.getSize()); System.out.println("当前栈的总长度:"+stack.getLength()); stack.printStack(); //出栈 int p = stack.pop(); System.out.println("当前出栈元素的值:"+p); System.out.println("当前栈元素个数:"+stack.getSize()); System.out.println("当前栈的总长度:"+stack.getLength()); stack.printStack(); //清空栈 stack.removeAll(); //stack.isEmpty(); int p2 = stack.pop(); System.out.println("当前出栈元素的值:"+p2); System.out.println("当前栈元素个数:"+stack.getSize()); System.out.println("当前栈的总长度:"+stack.getLength()); &#125;&#125; 测试结果： 1234567891011当前栈元素个数:3当前栈的总长度:7当前栈情况:8 9 10 当前出栈元素的值:8当前栈元素个数:2当前栈的总长度:7当前栈情况:9 10 栈为空！当前出栈元素的值:0当前栈元素个数:0当前栈的总长度:7 欢迎访问我的个人网站www.chlinlearn.cn到这里就要结束了，后续如果有时间也会出一篇链表实现栈的文章，欢迎来访问我的个人网站，最新文章都会首先在那里发布哦^^]]></content>
      <categories>
        <category>java,基础篇</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现DFA模拟程序]]></title>
    <url>%2F1.html</url>
    <content type="text"><![CDATA[DFA（确定的有穷自动机）一个确定的有穷自动机M是一个五元组：1M=(K，∑，f，S，Z) K是一个有穷集，它的每个元素称为一个状态。 ∑是一个有穷字母表，它的每一个元素称为一个输入符号，所以也陈∑为输入符号表。 f是转换函数，是Kx∑-&gt;K上的映象。 S∈K，是唯一的一个初态。 Z∈K，是一个终态集，终态也称可接受状态或结束状态。 实例代码 实现文法 1234G[S]: S-&gt;aU|bVU-&gt;bV|aQQ-&gt;aQ|bQ 状态图 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 -*- coding: utf-8 -*- ##@author: chlinlearn#@createTime: 2019/4/13 14:12#@fileName: DFAclass DFA(): def __init__(self): #状态集 self.listEdge = [] #初态 self.S = [] #终态 self.Z = [] #判断是否是终态集 def isZ(self,ch): for i in range(0,len(self.Z)) : if self.Z[0] == ch or self.Z[1] == ch: return True else: return False #输入 def input(self): self.S = input("请输入开始符：") self.Z = input("请输入终态集(终集符组成的一个字符串)：") self.Z = self.Z.split(",") print("请输入正规文法以exit结尾：") print("example:S,aZ") while(True): list = [] inStr = input() if inStr=='exit': break inStr = inStr.split(',') # 读取第一个状态集 s = inStr[0] for i in range(0,len(inStr[1])): #ch,ns if len(inStr[1])==2: c = inStr[1][0] n = inStr[1][1] list = [s,c,n] self.listEdge.append(list) elif len(inStr[1])==1: c = inStr[1][0] list = [s, c, self.Z[0]] self.listEdge.append(list) #转换函数 def isNextState(self,s,ch): for i in range(0,len(self.listEdge)): if s == self.listEdge[i][0] and ch == self.listEdge[i][1]: return self.listEdge[i][2] return def judgeDFA(self): print("请输入要判断的字符串:") while(True): #获取字母表 str = input() if '#' in str : print("程序已退出，欢迎下次使用!") return temp = self.S[0] for i in range(0,len(str)): if str[i] is 'a': temp = self.isNextState(temp,'a') elif str[i] is 'b': temp = self.isNextState(temp, 'b') else: break if self.isZ(temp): print("此字符串“属于”该文法！") else: print("此字符串“不属于”该文法！") print("再次判断请输入字符串(退出程序输入#):")if __name__ == '__main__': DFA = DFA() DFA.input() DFA.judgeDFA() 总结这是我在课程中的一个实验，代码手写并且可运行，是参照一个java版的代码实现的，加上自己的理解和思路把它以python的形式实现。学习别人好的地方，当然也不能照搬别人，不然能够为己用的东西少之又少。通过不同的编程语言把整个思路在理一遍能够加深自己的理解，并且能够得到一样的运行结果，说明自己的理解是对的。最后也附上对应的java版代码，有需求的童鞋可以参考喔！欢迎访问我的个人网站www.chlinlearn.cn 附件java版DFA 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import java.util.ArrayList;import java.util.List;import java.util.Scanner;class edge &#123; char PriorityState; char ch; char NextState; edge(char p,char c, char n)&#123; PriorityState = p; ch = c; NextState = n; &#125; @Override public String toString() &#123; return "edge [PriorityState=" + PriorityState + ", ch=" + ch + ", NextState=" + NextState + "]"; &#125;&#125;/**DFA的构造*/public class DFA &#123; static List&lt;edge&gt; listEdge = new ArrayList&lt;edge&gt;();//状态集 //static HashMap&lt;edge, Character&gt; mapEdge = new HashMap&lt;&gt;(); static String S;//初态集 static String Z;//终态集 //flag is here static boolean judeZ(char ch)&#123; for(int j=0; j&lt;Z.length(); j++)&#123; if(Z.charAt(j)==ch) return true; &#125; return false; &#125; static void input() &#123; Scanner in = new Scanner(System.in); String instr = null; String subStr[] = null; System.out.println("请输入开始符："); S = in.next(); System.out.println("请输入终态集(终集符组成的一个字符串)："); Z = in.next(); System.out.println("请输入正规文法以end结尾(形式如下图)："); System.out.println("----------"); System.out.println("| S-aU |"); System.out.println("| S-bV |"); System.out.println("| U-bV |"); System.out.println("| .... |"); System.out.println("| end |"); System.out.println("----------"); while(in.hasNext())&#123; instr = in.next(); if("end".equals(instr)) break; subStr = instr.split("-|\\|");//连字符 System.out.println("subStr:"+subStr); String s = subStr[0];//读取一行f(转换函数) System.out.println(s); for(int i=1; i&lt;subStr.length; i++)&#123; edge e = null; System.out.println(subStr[1]); if(subStr[i].length()==2)&#123; char c = subStr[i].charAt(0);//字母表 char n = subStr[i].charAt(1);//状态集 listEdge.add(new edge(s.charAt(0),c,n));//f(S,a)=U &#125; if(subStr[i].length()==1)&#123; char c = subStr[i].charAt(0); listEdge.add(new edge(s.charAt(0),c,Z.charAt(0))); &#125; &#125; &#125; &#125; static char judeNextState(char s,char ch)&#123; for(int i=0; i&lt;listEdge.size(); i++)&#123; if(s==listEdge.get(i).PriorityState &amp;&amp; ch==listEdge.get(i).ch)&#123; return listEdge.get(i).NextState; &#125; &#125; return '0'; &#125; static void judeDFA()&#123; Scanner in = new Scanner(System.in); System.out.println("请输入要判断的字符串:"); while(in.hasNext())&#123; String str = in.next(); if(str.equals("#"))&#123; System.out.println("程序已退出，欢迎下次使用!"); return; &#125; char temp = S.charAt(0); int i=0; //System.out.println(temp+" "+mapEdge.get(e)); for(; i&lt;str.length(); i++)&#123; //System.out.println("temp="+temp); if(str.charAt(i)=='a')&#123; temp = judeNextState(temp, 'a'); &#125; else if(str.charAt(i)=='b')&#123; temp = judeNextState(temp, 'b'); &#125; else break; &#125; //flag is here if(i&gt;=str.length() &amp;&amp; judeZ(temp)) System.out.println("此字符串“属于”该文法！"); else System.out.println("此字符串“不属于”该文法！"); System.out.println("再次判断请输入字符串(退出程序输入#):"); &#125; &#125; /*main*/ public static void main(String[] args) &#123; // TODO Auto-generated method stub DFA.input(); DFA.judeDFA(); &#125;&#125;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>DFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新篇章]]></title>
    <url>%2F1.html</url>
    <content type="text"><![CDATA[hi,大家好！准备了好久，下了很大的决心，终于可以开始更博啦！]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
</search>
