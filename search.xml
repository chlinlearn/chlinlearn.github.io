<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java学习笔记(基础篇)—IO流]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94io%E6%B5%81.html</url>
    <content type="text"><![CDATA[java学习笔记(基础篇)—IO流一：流的概念在Java中，把一组有序的数据序列称为流。 ​ 如a.txt的文件拷贝到b.txt中。 在Java中流是使用统一的方式操作输入和输出的数据。 从文件中读取，从键盘读取，从网络中读取…输出到文件，发送到网络…. 流就是一个对象。所在的包java.io.*，Java I/O系统负责处理程序的输入和输出，java.io包它对各种常见的输入流和输出流进行了抽象。 二：流的分类1)根据流操作的方向,参照物：当前程序​ a)输入流:将数据读取到程序中就是输入流，reader​ b)输出流:将程序中的数据写出到文件中就是输出流。writer 2)根据类操作的最小数据单元。​ a)字节类：如果数据流中最小的数据单元是字节，那么称这种流为字节流；字节流处理单元为 1 个字节，可以操作字节和字节数组 ​ b)字符类：如果数据流中最小的数据单元是字符，那么称这种流为字符流。字符流处理的单元为 2 个字节的 Unicode 字符，可以操作字符、字符数组或字符串Java内用Unicode 编码存储字符,字符流处理类负责将外部的其他编码的字符流和java内Unicode 字符流之间的转换。字符流（一次可以处理一个缓冲区）一次操作比字节流（一次一个字节）效率高。 3)根据流的角色​ a)节点流,如FileInputStream​ b)包装流/处理流，如BufferedInputStream。带有缓冲区 三：常用流a)java.io.InputStream和java.io.OutputStream 分别表示字节输入流和字节输出流， 是所有字节输入和输出流的父类.其中的方法参照下面的四 b)FileInputStream,FileOutputStream 针对文件进行字节操作。 c)BufferedOutputStream和BufferInputStream流 带有缓冲区的流。—调用flush()刷新缓冲流。 增强输入和输出流的性能。 提高读写的效率。 包装流是可以对其他流进行重新包装。 d)DataInputStream和DataOutputStream. 针对于基本数据类型进行操作 e)ObjectInputStream和ObjectOutputStream 针对于类类型的数据(对象)进行操作。 序列化：将对象保存到文件中或者传输到网络的过程。 反序列化：将文件中或者网络中将对象读取到程序的过程。 进行序列化或者反序列化的类必须实现Serializable接口。该接口是一个空接口， 只是起到了标识的作用，标识该对象可以进行序列化和反序列化serialVersionUID用来表明实现序列化类的不同版本间的兼容性。如果你修改了此类, 要修改此值。否则以前用老版本的类序列化的类恢复时会出错。 transient：该修饰的属性不会被序列化。是透明的属性。 f)PipedInputStream,PipedOutputStream 管道输入，输出流， 针对线程读取和写入数据 connect():管道输入流连接到管道输出流 g)Reader,Writer抽象类 是所有字符流输出和输入的父类。 字符流是在字节流的基础上进行字符编码(UTF-8,GBK,GB2312…) h)InputStreamReader,OutputStreamWriter 一组转换流—&gt;字节和字符之间的转换。 InputStreamReader：字节转换成字符的桥梁 OutputStreamWriter:字符转换成字节的桥梁 i)BufferedReader,BufferedWriter 带有缓冲区的字符流。 1)保存hello,您好时指定编码方式。 取数据时也指定编码方式。 2)采用这种方式完成文件的拷贝工作。 j)FileReader和FileWriter 针对文件的字符流 k)PrintWriter,PrintStream 都是输出流,可以进行格式化输出 PrintWriter:即可以包装字符类，也可以包装字节流。 PrintStream即可以输出字符，也可以输出字节 l)File对象m)RandomAccessFile 在文件的任意位置进行读和写的操作 seek(long),read(),writer(); 当操作大文件的时候使用该类。 四. 字节输入流和输出流概述在java.io包中，java.io.InputStream表示字节输入流，java.io.OutputStream表示字节输出流，它们都是抽象类，不能被实例化。 InputStream类提供了一系列和读取数据有关的方法： read(): 从输入流读取数据：有三种重载形式： a)int read(): 从输入流读取一个8位的字节，把它转换为0-255之间的整数，并返回这一整数。例如，如果读到的字节为9，则返回9，如果读到 的字节为-9，则返回247。如果遇到输入流的结尾，则返回-1; b)int read(byte[] b): 从输入流读取若干个字节，把它们保存到参数b指定的字节数组中。返回的整数表示读取的字节数。如果遇到输入流的结尾，则返回-1;c)int read(byte[] b, int off, int len): 从输入流读取若干个字节，把它们保存到参数b指定的字节数组中。 返回的整数表示读取的字节数。参数off指定在字节数组中开始保存数据的起始下标，参数len指定读取的字节数目。返回的整数表示实现读取的字节数。如果遇到输入流的结尾，则返回-1;以上第一个read方法从输入流读取一个字节，而其余两个read方法从输入流批量读取若干字节。在从文件或键盘读数据时，采用后面两个read方法可以减少进行物理读文件或键盘的次数，因此能提高I/O操作的效率。 void close(): 关闭输入流，InputStream类本身的close()方法不执行任何操作。它的一些子类覆盖了close()方法，在close()方法中释放和流有关的系统资源。 int available(): 返回可以从输入流中读取的字节数目； skip(long): 从输入流中跳过参数n指定数目的字节。 boolean markSupported()，void mark(int)，void reset(): 如果要从流中重复读入数据，先用markSupported()方法来判断这个流是否支持重复读入数据，如果返回true，则表明可以在流上设置标记。接下来调用mark(int readLimit)方法从流的当前位置开始设置标记。最后调用reset()方法，该方法使输入流重新定位到刚才做了标记的起始位置。这样就可以重复读取做过标记的数据了。 OuputStream类提供了一系列和写数据有关的方法： write(): 向输出流写入数据：有三种重载形式：a)void write(int b):向输出流写入一个字节；b)void write(byte[] b): 把参数b指定的字节数组中的所有字节写到输流；c)void write(byte[] b, int off, int len): 把参数b指定的字节数组中的所有字节写到输出流，参数off指定字节数组的起始下标，从这个位置开始输出由参数len指定数目的字节； 以上第一个write方法从输出流写入一个字节，而其余两个write方法从输出流批量写出若干字节。在向文件或控制台写数据时，采用后面两个write方法可以减少进行物理读文件或键盘的次数，因此能提高I/O操作的效率。 void close(): 关闭输出流，OutputStream类本身的close()方法不执行任何操作。它的一些子类覆盖了close()方法，在close()方法中释放和流有关的系统资源。 void flush(): OutputStream类本身的flush()方法不执行任何操作，它的一些带有缓冲区的子类(比如BufferedOutputStream和PrintStream类)覆盖了flush()方法。通过带缓冲区的输出流写数据时，数据先保存在缓冲区中，积累到一定程度才会真正写到输出流中。缓冲区通常用字节数组实现，实际上是指一块内存空间。flush()方法强制把缓冲区内的数据写到输出中。 五：IO操作的步骤 1)选择合适的流 2)创建流对象 3)进行读写的操作 4)关闭资源 关注作者微信公众号：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(初级篇)—网络]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9D%E7%BA%A7%E7%AF%87-%E2%80%94%E7%BD%91%E7%BB%9C.html</url>
    <content type="text"><![CDATA[java学习笔记(初级篇)—网络一：计算机网络计算机网络是连接全球计算机资源的网络环境可以资源共享，通信等最简单的网络形式由两台计算机组成。 二：网络的协议协议：在网络上进行数据通信(数据交换)时所使用的规范(标准)。不同层具有各自不同的协议。 三:OSI(Open System Interconnection)参考模型物理层：二进制传输，确定如何在通信信道上传递比特流；数据链路层：加强物理层的传输功能，建立一条无差错的传输线路；网络层：在网络中数据到达目的地有很多线路，网络层就是负责找出最佳的传输路；传输层：传输层为源端计算机到目的端计算机提供可靠的数据传输服务，隔离网络的上下层协议，使得上层网络应用的协议与下层无关；会话层：在两个相互通信的应用进程之间建立、 组织和协调其相互之间的通信；表示层：处理被传送数据的表示问题，也就是信息的语法和语义，如有必要将使用一种通用的格式在多种格式中进行转换；应用层：为用户的应用程序提供网络通信服务； OSI(Open System Interconnection)参考模型并不是物理实体上存在这七层，这只是功能的划分，是一个抽象的参考模型。进行网络通信时，每层提供本层对应的功能；1）通信实体的对等层之间不允许直接通信， 它们之间是虚拟通信，实际通信在最底层完成；2）各层之间是严格单向依赖；3）上层使用下层提供的服务 — Service user；4）下层向上层提供服务 — Service provider。5）对等层实体之间虚拟通信；6）下层向上层提供服务，实际通信在最底层完成。 OSI各层所使用的协议1）应用层：远程登录协议Telnet、文件传输协议FTP（网上下载一个软件或者资料的时候就会使用该协议）、 超文本传输协议HTTP（使用较多，通过IE浏览一个网页的时候就使用该协议）、域名服务DNS（使用较多，通过网络访问一个计算机一般不使用该主机的IP地址，而是通过该主机的域名访问）、简单邮件传输协议SMTP（通过Foxmail发送邮件）、邮局协议POP3等（通过Foxmail收邮件); 2）传输层：传输控制协议TCP、用户数据报协议UDP；TCP：面向连接的可靠的传输协议；在利用TCP协议进行通信的时候，首先要经过三步握手建立起通信双方的连接，一旦连接建立后就可以通信了。TCP协议提供数据确认和重传的机制，保证数据一定能够到达数据接收端。像打电话。 UDP：是无连接的，不可靠的传输协议；采用UDP协议进行通信时，不需要建立连接，可以直接向一个IP地址发送数据，至于是不是能够收到不能保证，发送过程中数据有可能丢失、IP地址可能不存在、再者IP地址代表的主机没有运行等原因都可能导致不能接收到数据。 TCP/IP:有保障，成本较高。是一种可靠的协议，通信之前先建立连接。适合较小的数据量，保障通信质量。 如：上传和下载文件。UDP：无保障，通信成本较低。是一种不可靠的协议，通信之前不会建立连接，发数据包中包含目的地的地址。适合于大数据量，不介意丢失少量数据的通信。 如：视频聊天 3）网络层：网际协议IP、Internet互联网控制报文协议ICMP、Internet组管理协议IGMP。 四：IP地址和端口号IP地址：最重要的路由寻址1）网络中每台主机都必须有一个惟一的IP地址；2）IP地址是一个逻辑地址；3）因特网上的IP地址具有全球唯一性；4）32位，4个字节，常用点分十进制的格式表示，例如：192.168.0.16。 端口：用来标识唯一的应用程序使用一个16位的数字来表示，它的范围是0–65535,1024以下的端口号保留给预定义的服务。例如：23-telnet,21-ftp,25-邮件传输,http使用80端口 五：基于TCP的Socket编程步骤：套接字：代表通信节点1）服务器程序编写： ①调用ServerSocket(int port)创建一个服务器端套接字，并绑定到指定端口上； ②调用accept()，监听连接请求，如果客户端请求连接，则接受连接，返回通信 套接字； ③调用Socket类的getOutputStream()和getInputStream获取输出流和输入流， 开始网络数据的发送和接收； ④最后关闭通信套接字。2）客户端程序编写： ①调用Socket()创建一个流套接字，并连接到服务器端； ②调用Socket类的getOutputStream()和getInputStream获取输出流和输入流， 开始网络数据的发送和接收； ③最后关闭通信套接字。 六：基于UDP的Socket编程步骤： 1）服务器端基于UDP编程： a)调用DatagramSocket(int port)创建一个数据报套接字，并绑定到指定端口上； b)调用DatagramPacket(byte[] buf, int length)，建立一个字节数组以接收客户端 的UDP包 ； c)调用DatagramSocket类的receive()，接收客户端的UDP包并放在上一步创建的 数据包中； 通过调用DatagramPacket的getData获取数据。 d)创建数据包，用来存放发送给客户端响应数据。 int port = dp.getPort(); InetAddress address=dp.getAddress(); String msg=new Date().toString(); buf=msg.getBytes(); DatagramPacket dp1=new DatagramPacket(buf,buf.length,address,port); ​ e)向客户端发送数据包DatagramSocket.send(DatagramPacket)​ f)最后关闭数据报套接字。其中第四，五是选择性的。 2）客户端程序编写：​ a)调用DatagramSocket()创建一个数据报套接字。​ b)调用DatagramPacket(byte[] buf, int length,​ InetAddress address, int port)，建立要发送的UDP包；​ 包含发给服务器的数据，服务器地址，服务器的端口。​ c)调用DatagramSocket类的send(dp)，发送UDP包；​ d)创建数据包，用来存放服务器端返回响应数据。​ DatagramPacket dp1=new DatagramPacket(buf,buf.length);​ e)接收服务器端响应数据ds.receive(dp1);​ f)最后关闭数据报套接字。​ 其中第四，五是选择性的。 七、概念URI：统一资源标识符URL：统一资源定位符 http://www.baidu.comURN：统一资源命名符 关注作者微信公众号：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(中级篇)—单例模式]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%AD%E7%BA%A7%E7%AF%87-%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[java学习笔记(中级篇)—单例模式一、概念单例模式就是在一个java应用程序中，一个class类只有一个实例。 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 二、好处我们知道JVM的内存资源是很宝贵的，尤其是在程序很庞大的时候，尽量减少创建不必要的对象是能够很大程度的减少内存的开销。单例模式的好处就是能够节省内存，限制了实例对象的创建。 三、使用场景在一个应用程序中的共享资源可以考虑使用单例模式，比如日志、配置、数据连接池、线程池等；熟悉servlet的童鞋一定知道，servlet组件也是单例模式的，因为频繁的创建servlet线程会消耗大量资源，影响系统性能，这也是单例模式的好处体现。 四、简单实现单例模式有种实现方式： 恶汉式 所谓恶汉式，就是提前先创建好实例对象，直接拿就好了； 懒汉式 所谓懒汉式，就是需要用的时候再创建；懒汉式的缺点是非线程安全，只有加上关键字synchronized才能保证同步，但是会降低效率。 实现要素： 构造器私有化 实例对象私有化 创建公有的方法返回一个实例对象 代码实现 懒汉式 //单例模式-懒汉式 public class Singleton { private static Singleton singleton = null; private Singleton() {} public static synchronized Singleton getInstance() { if (singleton==null) { singleton = new Singleton(); } return singleton; } } 恶汉式 //单例模式-恶汉式 public class Singleton2 { private static Singleton2 singleton2 = new Singleton2(); private Singleton2() {} public static Singleton2 getInstance() { return singleton2; } } 关注作者微信公众号：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>中级篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—线程]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94%E7%BA%BF%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、线程与进程线程是程序执行的最小单位，是动态的。进程是系统进程资源分配和系统调度的最小单位，是动态的。线程和进程的目的：多任务—&gt;效率高 同时性 在同一个时间点只能执行一个进程或线程 在同一个时间段可以执行多个进程或线程 多进程的数据不共享，每个进程都有自己的独立内存空间。多线程数据的进程的数据是共享的，每一个线程又有自己独立堆栈区空间。线程与线程之间是独立的，相互之间不受影响。 一个程序可以启动多个进程一个进程可以启动多个线程线程必须通过进程启动，不能独立存在的。 .class运行在JVM上，.class就是一个一个的线程。JVM就是一个进程。 二：线程的三要素CPU：运行线程，所有线程共享CPU。只有线程抢占CPU成功才会执行。 代码：线程运行过程中执行的代码块。线程启动之后会执行public void run()的方法。 数据：​ 1)局部变量是多线程不共享​ 2)extends Thread方式实现多线程，静态变量是共享，实例变量不共享​ 3)implements Runnable方式实现多线程，静态变量是共享的，实例变量也共享 三：使用线程第一种方式：class MyThread extends Thread{ public void run(){ } } 建线程：Thread t1=new MyThread(); //不要t1.run()来企图启动线程，那是单纯的调用该方法，并没有启动一个线程 启动线程： t1.start(); 第二种方式：class MyThread implements Runnable{ public void run(){ } } 创建线程：MyThread m=new MyThread(); Thread t1 = new Thread(m); 启动线程： t1.start(); Thread类中的方法：getName(): 获取当前线程的名字static sleep(long): 强制当前正在执行的线程休眠(暂停执行),只是让出CPU,但不会释放锁。static currentThread(): 获取当前正在执行的线程。 Thread类中的方法：getName():获取当前线程的名字static sleep(long):强制当前正在执行的线程休眠(暂停执行),以“减慢线程”。static currentThread():获取当前正在执行的线程。 注意：线程的运行时抢占式，所以线程的执行结果是不可预知的。 四：为什么要有两种方式java单继承 class Test extends Student implements Runnable{ } 五：线程的状态a)新建状态(new)：线程对象已经创建，还没有在其上调用start()方法。 b)就绪状态(Runnable)： 线程已经准备好了，等待CPU的调度，当线程有资格行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入就绪状态。在线程运行之后或者从阻塞、等待或睡眠状态回后，也返回到就绪状态。就绪状态维护了一个线程池。 所有的就绪状态的线程都会进入到线程池中。 c)运行状态(Running)：线程调度程序从可运行池中选择一个线程作为 当前线程时线程所处的状态。这也是线程进入 运行状态的唯一一种方式。CPU正在执行的线程。 d)等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，但是当前没有条件运行。换句话说，它是可运行的，但是如果某件事件出现，他可能返回到就绪状态。 e)死亡状态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。 六：中断线程：让线程正常结束，到死亡状态1)使用标志变量中断线程。就好像开车一样。2)使用stop()已经过时了,虽然它确实停止了一个正在运行的线程，然而，这种方法是不安全也是不受提倡的。 Thread类中的方法：join(): 等待线程的执行结束。在哪个线程中调用就谁等待。谁调用该方法就等待谁。interrupt(): 中断阻塞中的线程。不能中断正在执行的线程。isInterrupted(): 判断是否被中断static interrupted(): 清空中断信息 七：线程的并发访问：多线程同时操作同一个对象。synchronized(共享区){临界区}共享区：多线程同时操作同一个对象临界区：多线程对共享区进行操作的代码区将所有影响的方法都定义成线程安全的方法就变成了线程安全的类。synchronized可以放在方法上，就是一个同步方法。 同步锁有很多种，这里只是简单的描述了一下synchronized关键字，关于具体的使用和细节，后续会专门推出一篇文章来讲。 欢迎访问我的腾讯云+社区：传送门]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—内部类]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94%E5%86%85%E9%83%A8%E7%B1%BB.html</url>
    <content type="text"><![CDATA[java学习笔记(基础篇)—内部类一、内部类1.顶层类和内部类的区别： 1)位置: 内部类是定义一个类的里面或者一个方法中,或者一个表达式中。 顶层类是定义在package下 2)修饰符：顶层类只能处于public和默认访问级别， 成员内部类可以处于public, protected, private和默认这4种访问级别； 2.作用： 1)可以避免命名冲突。 2)定义类的范围从package变成了类。在一个类的内部定义的类称为内部类。 3)进行再一次的封装 4)分担外围类的功能 3.内部类的分类：​ 变量按照作用域可分为：​ 1) 成员变量: 实例变量、静态变量；​ 2) 局部变量；​ 同样，内部类按照作用域可分为；​ 1) 成员内部类: 实例内部类、静态内部类；​ 2) 局部内部类；放在方法里​ 3) 匿名内部类 a) 静态内部类: 用static修饰,相当于静态方法。放在方法外，类里面的。静态内部类具有以下特点：1)静态内部类可以直接访问外部类的静态资源。如果静态内部类中的变量名字和外围类的变量名字相同，需要指定访问时的谁的名字。2)静态内部类如果访问外部类的实例成员， 就必须通过外部类的实例去访问。3)静态内部类的实例不会自动持有外部类的特定实例的引用， 在创建静态内部类的实例时，不必创建外部类的实例。4)在静态内部类中可以定义静态成员和实例成员。5)外围类可以通过完整的类名直接访问静态内部类的静态成员。6)外围类可以通过内部类对象调用静态内部类对象的非静态成员。7)在静态内部类中和外围类中创建静态内部类的对象: 静态内部类类名 m=new 静态内部类类名(); 在其他类中创建静态内部类的对象: 外围类.静态内部类类名 m= new 外围类.静态内部类类名(); b)实例内部类：没有static修饰符。相当于成员变量。放在方法外，类里面的。特点：1)在内部类中,可以直接访问外部类的所有资源(属性和方法)。2)成员内部类不能定义静态的资源，只能定义非静态的资源。3)外围类不能直接访问成员内部类的资源.先创建成员内部类的对象，在通过调用非静态资源(对象.资源).4)在成员内部类中和外围类中创建成员内部类的对象成员内部类中: 类名 m=new 成员内部类类名(); 外围类中: 类名 m=this.new 成员内部类类名(); 在其他类中创建成员内部类的对象: 外围类.成员内部类类名 m=new 外围类().new 成员内部类类名(); 5)在创建实例内部类的实例时,外部类的实例必须已经存在。6)在成员内部类中调用外围类中同名资源: 外围类.this.资源 7)如果实例内部类B与外部类A包含同名的成员，那么在类B中，this.v表示类B的成员， A.this.v表示类A的成员8)实例内部类的实例自动持有外部类的实例的引用。9)外部类实例与内部类实例之间是一对多的关系，一个内部类实例只会引用一个外部类实例，而一个外部类实例对应零个或多个内部类实例。 c) 局部内部类: 在一个方法中定义的内部类，它的可见范围是当前方法。和局部变量一样。特点：1)局部内部类只能在当前方法中使用。2)局部内部类和实例内部类一样，不能包含静态成员。3)在局部内部类中定义的内部类也不能被public、 protected和private这些访问控制修饰符以及static修饰（都是局部的）;4)可以访问外部类的所有成员。5)局部内部类还可以访问所在方法中的final类型的局部变量。final延长局部变量的生命周期。 d)匿名内部类：在一个方法中定义的内部类，它的可见范围是当前方法。和局部变量一样。特点：1)没有类名，使用接口或者抽象类代替类名2)访问外围类的一切资源(方法和属性)3)访问该方法final修饰的局部变量，jdk1.8以后不需要4)放在方法中或者作为参数。 几种内部类的区别： 创建a. 声明的位置: 静态内部类：类的内部，方法的外部，用static关键字修饰； 实例内部类：类的内部，方法的外部，不用static关键字修饰； 局部内部类：方法的内部； 匿名内部类：既可以在类的内部，方法的外部，也可以在方法的内部； b. 实例化方式: 静态内部类：new Outer.Inner(); //在外部类外创建； new Inner(); //在外部类内内部类外创建 实例内部类：new Outer().new Inner(); //在外部类外创建； this.new Inner(); //在外部类内内部类外创建 局部内部类：new Inner(); //只能在方法内部创建 匿名内部类：new 类名() {}; 访问 a. 外部类访问内部类： 静态内部类：通过完整的类名直接访问静态内部类的静态成员; 实例内部类：通过内部类的实例去访问内部类的成员; 局部内部类：不能访问； 匿名内部类：不能访问； b. 内部类访问外部类： 静态内部类：直接访问外部类的静态成员； 实例内部类：可以直接访问外部类的所有成员; 如果实例内部类B与外部类A包含同名的成员，那么在类B中， this.v表示类B的成员， A.this.v表示类A的成员。 局部内部类：可以直接访问外部类的所有成员, 访问所在方法中的final类型的参数和变量； 匿名内部类：可以直接访问外部类的所有成员, 访问所在方法中的final类型的参数和变量； //成员内部类，静态内部类 StaticInnerTest.class StaticInnerTest$MaxMin.class //局部内部类 LocalInnerTest.class LocalInnerTest$1MaxMin.class //匿名内部类 AnonymousInnerTest.class AnonymousInnerTest$1.class 内部类的使用：图形化界面中组件的监听事件工厂模式,在内部类只有在该外围类有意义，出了该外围类就没有意义了， 就可以将该类定义成内部类。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—集合]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[java学习笔记(基础篇)—集合一、集合框架的组成，在java.util包中。 1)接口：定义需要实现的抽象方法。 2)实现类：将接口中的方法实现，如ArrayList,Hashtable等 3)算法：存放和操作数据的算法。如哈希算法，红黑树算法… Collection(顶层接口) -List(接口) -ArrayList -Vector -LinkedList -Set(接口) -HashSet -SortSet(接口) -TreeSet -Map(接口) -HashMap -TreeMap -Treetable ... 二、集合的层次结构a)：保存单值Collection:定义保存单值的规范 ——Set:定义保存不可重复无序单值的规范 ———HashSet:哈希算法保存数据，检索效率最高的 ———SortedSet：定义在Set基础上进行排序的规范 ———TreeSet：实现排序规则 ——List:定义保存可重复有序单值的规范 ——LinkedList：使用链表实现List接口 ——Vector：使用数组实现List接口，线程安全的 ——ArrayList：使用数组实现List接口，线程不安全 b)保存键值对（key—value）Map：定义保存键值对的规范（key不能重复，value可重复） ————HashMap:是线程不安全,效率高,HashMap允许null key和null value， ————HashTable:是线程安全,Hashtable不允许null key和null value， ——SortedMap:定义在Map的基础上进行排序的规范(根据key排序) ————TreeMap：对map进行排序 c)Map类中的方法：HashMap,Hashtableput(Object key,Object value):添加数据到map集合中Set keySet():将map中所有的key取出来放在set集合中Object get(Object key):从map集合中获取数据。Set entrySet():将map中的key和对应的value重新创建成新的对象(Map.Entry)放在set集合中。 Map.Entry:getKey() Map.Entry:getValue()Set values():将map中所有的value取出来放在collection集合中 interface Map{ static interface Entry{ } } 三、增强for循环 a)之前的for循环 for(初始化变量;循环条件;变量的控制){ 循环体 } b)增强for循环：方便遍历集合和数组 for(type element : array){ 循环体 } type:数组或集合中数据的数据类型 element:临时变量 array:数组或集合的引用注意：增强for遍历的集合必须是实现Iterable接口。不能明确指出数据的下标（位置） 四、set添加元素的时候，如何判断两个对象是否相等？1）先比较hashCode的值，如果hashCode的值不相等，不会比较equals方法，直接返回两个对象不相等。2）先比较hashCode的值，如果hashCode的值相等，再比较equals方法，如果equals比较两个对象不相等，返回这两个对象不相等。 五、如何判断元素应该添加在set集合的那个地方？(hashCode的作用)1)使用哈希算法可以提高检索的效率。 哈希算法底层有一张哈希表。哈希表相对于数组。 哈希表的长度根据算法自己的计算出来的。2)底层使用哈希算法决定对象所存放的位置 ​ 所放的位置=通过对象的hashCode%哈希表的长度 一个对象默认hashCode值是由对象的地址根据一定算法计算而得出来的。set中添加元素判断对象是否相同需要重写hashCode方法和equals方法。如何重写hashCode方法：在java.lang.Object中重写hashCode方法建议：每个不同的对象放在不同的位置将所有会影响判断对象是否相同的属性的hashCode值相加。 public int hashCode(){ //return 1; return 所有的属性的hashCode值相加; } 六、TreeSet,TreeMap排序：1）自然排序：将需要排序的类实现java.lang.Comparable interface java.util.Comparator{ public int compare(Object o1,Object o2){ ..排序规则 } } public class Student implements Comparable{ public int compareTo(Object obj){ ..排序规则 } } 2）覆盖排序：创建TreeSet,TreeMap对象指定排序规则。 当该类无法指定自然排序，就只能使用覆盖排序。如final String类不能用自然排序，只能用覆盖排序。 **覆盖排序的优先级高于默认排序Set set = new TreeSet();set.add(“b”);set.add(“a”);set.add(“d”);set.add(“c”);***该代码有没有问题？如果没有问题输出什么内容？]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—面向对象编程之封装、多态和继承]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%B0%81%E8%A3%85%E3%80%81%E5%A4%9A%E6%80%81%E5%92%8C%E7%BB%A7%E6%89%BF.html</url>
    <content type="text"><![CDATA[java学习笔记(基础篇)—面向对象编程之封装、多态和继承一. OOP中的基本概念Java的编程语言是面向对象的，采用这种语言进行编程称为面向对象编程(Object-Oriented Programming, OOP)， 它允许设计者将面向对象设计实现为一个可运行的系统。Java的编程单位是类，对象最后要通过类进行实例化(即“创建”)。面向对象编程有三个特性：封装，继承，多态 封装：对类中的属性和方法的具体实现进行封装（隐藏），外界不可见 继承：继承父类中的属性和方法 extends class 子类 extends 父类 都是单继承 多态：同一个领域中(继承同一个类或者实现同一个接口)的不同对象调用相同的方 法表现不同。 二. 封装1.类和对象类是具有相同属性和行为的对象的集合。对象是类的具体化，对象是唯一的。类是具有一组相同属性和行为的抽象化模板，类是对象的抽象。 对象是对问题领域中事件的抽象。对象具有以下特性：1) 万物皆为对象。问题领域中的实体和概念都可以抽象为对象。例如学生，成绩单、教师、课和教室。2) 每个对象都是惟一的。3) 对象具有属性和行为。4) 对象具有状态。状态是指某个瞬间对象的各个属性的取值。对象的某些行为会改变对象自身的状态，即属性的取值。 5) 每个对象都是某个类的实例。小张和小王都属于学生类、中国和美国都属于国家类、中文和英文都属于语言类。同一个类的所有实例都有相同属性，但属性取值不一事实上相同，但是它们的状态不一定相同。例如：小张和小王都属于学生类，都有姓名、性别、年龄、身高和体重这些属性，但是他们的属性取值不同。同一个类的所有实例都有相同行为，意味着它们具有一些相同的功能。 类是一组具有相同属性和行为对象的模板。面向对象编程的主要任务就是定义对象模型中的各个类：1) 类是一种类型：是引用类型；2) 类是元数据：描述数据的数据，数据在面向对象领域里以对象的形式存在，类是对象共有属性和方法的抽象描述。 2. 定义方法形式格式： 修饰符 返回类型 方法名（参数列表）异常抛出类型{方法体} 参数列表：传入数据返回值类型：传出数据的类型没有返回值，必须写void修饰符：访问修饰符public,private或者static,final。没有优先级 public int getValue(int value){ if(value>10){ return value+10; } } 2. 参数传递：实参传递给形参 形参：方法声明时的参数 实参：方法调用时传递的参数1）值传递：传递的是数值 参数是基本数据类型的时候，采用值传递2）地址传递：传递的是地址 参数是引用数据类型的时候，采用地址传递 3. this关键字: 当前对象​ 1)区分实例变量和局部变量​ this.name=name;​ 2)调用本类的构造器​ this(参数列表);​ 3)调用本类的方法​ this.方法名() 4. 数据隐藏 好处：防止外界进行非法修改 如何实现：1)数据的访问修饰符private 2)提供统一的操作(属性的set,get) 数据隐藏就是封装的一个方面，封装的另一个方面隐藏方法。 5. 方法重载对于类的方法(包括从父类中继承的方法), 如果有两个方法的方法名相同，但参数不一致，那么可以说，一个方法是另一个方法的重载方法。这种现象叫重载。方法的重载满足的条件： 1)在同一个类中 2)方法名相同 3)参数列表不相同 a)参数个数不相同 || b)参数类型不相同 || c)参数列表的顺序不相同 4)返回值类型可以不同 5)访问修饰符可以不同 注意：在一个类中不允许定义两个方法名相同，并且参数签名也完全相同的方法。因为假如存在这样的两个方法，Java虚拟机在运行时就无法决定到底执行哪个方法。参数签名是指参数的类型、个数和顺序。 6. 创建和初始化对象(new)public class Person{ private String name="briup"; } Person p=new Person(); 1)在栈区开辟空间保存对象的引用2)在堆区开辟空间保存对象本身的数据3)堆区的地址赋值给栈区的对象的引用4)为对象的属性进行默认初始化(系统完成)5)为对象的属性进行显示初始化6)调用普通代码块{}7)调用构造器 7. 构造方法构造器：根据用户需求传入数据, 然后根据传入数据对属性进行初始化。作用：为属性进行初始化 1）方法名和类名相同 2）没有返回值类型 3）构造的重载(根据不同的情况调用不同的构造器进行相应的初始化)调用本类的 构造器:this(参数列表)，必须放在方法的第一行。 4)系统会提供一个无参的构造器， 但是如果本类实现了其他的构造器，系统提供的无参构造器失效。 public class Test{ public Test(){} public void Test(){} //普通的方法 } 二：继承好处：代码复用，简化编程 代码复用用在哪些地方： 1)复用父类的属性 2)复用父类的方法(直接调用父类的方法) 3)重写父类的方法实现：class 子类 extends 父类 java是单继承，但也不是绝对的单继承，java中有接口，一个接口可以继承多个接口，一个类也可以实现多个接口，具体的内容会在接口那篇文章中说明。 关系：子类 is a 父类 或者 子类 is a like 父类 class Student extends Person student is a Person Person is a Student（error） 子类继承父类哪些：1）构造器不能继承 2）方法和属性全部继承，private声明的可以继承，但子类不能使用，只有父类本身才能使用。 继承注意的问题：1)创建一个子类对象必须先创建一个父类对象2)子类的构造器会默认调用父类的无参构造器super();3)父类的无参构造器失效，子类构造器就需要显式的调用父类存在的其他构造器super(参数列表);4)当一个子类继承了一个父类后，父类中所有的字段和方法都被子类继承拥有，子类可以任意的支配使用，每个子类对象中都拥有了父类中的所有字段。当构造一个子类的实例对象时，该对象的实例变量包括了子类本身以及父类中的所有实例变量，实例方法也包括了子类和父类中的所有实例方法。子类构造器用来初始化子类中所有的实例变量，而父类构造器super(实参)用来初始化父类中所有的实例变量。那么在堆中为子类实例对象分配的内存区域中包括了子类和父类中所有初始化后的实例变量。5)在构造器不能同时出现this和super，并且this和super只能出现在构造器的第一行，否则会报错。 1. super代表父类对象，this代表当前对象 1) 调用父类的属性(很少用)，因为都是私有的，不能调用 super.name=name; 2) 调用父类的构造器 super(参数列表); 3) 调用父类的方法(子类中包含和父类相同的方法名) super.方法名(参数列表); 2. 方法的重写 条件：当父类的方法不能够满足子类方法的需求。 就可以对父类的方法进行重写 1)发生在子父类 2)方法名必须相同 &amp;&amp; 参数列表必须相同 &amp;&amp; 返回值类型必须相同 3)可见性(访问修饰符)不能变小 4)异常不能扩大 加上@Override让编译器来检查是否是一个重写方法 三：多态概念：同一领域中的不同对象调用相同的方法表现不一样。 静态数据类型：变量申明时候的类型，编译时动态数据类型：创建对象时的数据类型，运行时对象真正的数据类型是动态数据类型决定的，运行时数据类型 实现多态必须满足什么条件： 1)子类必须重写父类中的方法 2)父类的引用指向子类的对象: 父类 变量 = new 子类(); Person p=new Student();]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—反射]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94%E5%8F%8D%E5%B0%84.html</url>
    <content type="text"><![CDATA[java学习笔记(基础篇)—反射一、反射 ：自描述或者自定义一个类或者对象通过反射可以获得自身的对象，该对象是一个java.lang.Class的对象(就像一个镜像文件)。一个对象或者类获得自身的Class对象的过程称为反射。java.lang.Class：是类镜像，镜像对象Class类镜像的作用可以获取该类和该对象的所有属性，方法和构造器，以及属性方法和构造器修饰符，修改私有属性的值。调用方法和调用构造器等等。Class—-实例化—–&gt;class—–实例化—–&gt;对象对象——抽象化—–&gt;class——抽象化—–&gt;Class抽象：具有相同属性和行为抽象出来 public final class Class{ Field[] fileds; Method[] methods; Constructor[] cons; } 反射API：java.lang.Class java.lang.reflect.Field java.lang.reflect.Method java.lang.reflect.Array java.lang.reflect.Constructor class Person{}Person创建100个对象，创建多少个Person的Class类型对象？ 1个，类加载的时候创建Person的Class类型对象。 通过反射操作的步骤：1）获取类镜像(Class对象),三种方式 a)Class.forName(String className) b)数据类型.class c)对象.getClass()2)通过类镜像实例化对象(不通过new方式创建对象) Object obj=类镜像对象.newInstance()。 ​ 默认会调用class类的无参构造器。 3)通过实例化对象操作属性，方法，构造器 a)获取所有的属性(属性名和修饰符和数据类型)。 b)获取所有的方法(方法名和修饰符和返回值和参数列表) c)获取所有构造器(名字和修饰符和参数列表) d)修饰属性的值 e)调用方法:invoke() f)调用指定构造器创建的对象 什么时候用反射： 1)在运行的时候才知道类名 2)在运行的时候才知道属性名 3)在运行的时候才知道方法名 反射：​ 1) 确定一个对象的class​ 2) 可以获得一个类的修饰符、字段、方法、构造器和父类。​ 3) 获得接口声明的常量和方法。​ 4) 创建Class的实例，直到运行时才获得。​ 5) 运行前即使字段名字不知道，可以到程序运行时获得和修改这些字段的值。​ 6) 运行前即使对象的方法名不知道，可以到程序运行时触发调用该方法。​ 7) 运行前创建了一个大小和元素都未知的新数组，​ 可以到运行时修改数组的元素。 反射的用途： 1)修改私有属性的值 2)调用任何对象的任何方法 3)不通过new方式创建对象 反射用途的注意：1)反射可以让我们利用这个Class对象来获取和修改私有的变量和方法，不通过共有的方法去获得（原来我们例子都是通过一个public的方法来设置和获取私有的变 量），可以破坏数据的封装性。2)反射机制通过在运行时探查字段和方法，从而可以帮助写出通用性很好的程序，这项能力对系统编程来说特别有用，但它并不适合于应用编程。而且，反射是脆弱的——编译不能帮助你发现编译错误，任何错误在运行时被发现并且都会导致异常。导致代码不安全。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—关键字static和final]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94%E5%85%B3%E9%94%AE%E5%AD%97static%E5%92%8Cfinal.html</url>
    <content type="text"><![CDATA[java学习笔记(基础篇)—关键字static和final一、关键字Static 我们从关键字static可以修饰哪些东西入手，逐一的剖析static的使用和要注意的地方。 1)修饰变量(只能修饰实例变量)—–&gt;静态变量 又称为类变量 a)所有类实例共享b)使用静态变量 类名.变量名c)静态变量是属于这个类，非静态变量是属于对象d)代码加载到内存静态变量就已经存在了e)static变量和实例变量的区别： i)static变量对于每个类而言在内存中只有一个，能被类的所有实例所共享； 实例变量对于每个类的每个实例都有一份，它们之间互不影响； ii)Java虚拟机在加载类的过程中为static变量分配内存， 实例变量在加载完类后创建对象时分配内存； iii)static变量存在方法区，实例变量存在堆区； v)static变量可以直接通过类名访问， 实例变量通过引用类型变量访问； 2)修饰方法====&gt;静态方法 称为类方法 a)调用时使用 类名.方法名();b)静态方法不能使用非静态的变量 静态方法在类加载的时候就存在了 非静态变量在对象创建的时候才存在的 非静态方法可以访问静态变量c)静态方法不能被非静态方法重写，静态方法不能被静态方法重写(总之就是不能被 重写)d)静态方法用来表示某个类所特有的功能，这种功能的实现不依赖于类的具体实例，也不依赖于它的子类。既然如此，当前类必须为静态方法提供实现。静态方法属于类。e)不能使用this关键字和super关键字；（考虑它的生命周期来理解） this表示的当前对象，而被static修饰的是属于类的，不需要创建对象就可以使用；super是代表父类对象，调用父类的静态方法直接使用类名.方法名就可以。 3)静态初始化块—-在类加载时只执行一次​ 对静态变量进行初始化，当Java虚似机加载类时，就会执行该代码块；被static 所修饰的成员变量和成员方法表明归某个类所有，它不依赖于类的特定实例，被 类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据 区的方法区内定位到它们。而且只会被加载一次。 static{ System.out.print("hello static"); } 4)普通初始化—-每创建一个对象都会被调用的对非静态变量进行初始化： { System.out.print("hello static"); } 5)静态导入 这个用法一般不太出现，很少使用。 import java.lang.Math; 使用：Math.random() import static java.lang.Math.*; 使用：random() 6)补充知识 创建一个对象时的类加载步骤或者说顺序: Student student =new Student();猜猜它的执行顺序会是什么？我们来理一理逻辑，子类继承父类，创建一个子类对象首先要有一个父类被创建，Student（）构造器里默认有一个super()方法，所有会先初始化父类，然后是初始化子类的部分。下面来看具体的步骤： public class Student extends Person{ private static String name; private int age; public Student() { System.out.println("this student constructor"); } static { System.out.println("this is student static block"); } { System.out.println("hello student"); } public static void main(String[] args) { Student stu = new Student(); } } class Person{ private static int count; private String title; public Person() { System.out.println("this person constructor"); } static { System.out.println("this is person static block"); } { System.out.println("hello person"); } } 父类初始化静态变量和静态代码块(按先后顺序执行)； 子类初始化静态变量和静态代码块(按先后顺序执行)； 父类初始化非静态变量和非静态代码块(按先后顺序执行)； 父类构造器 子类初始化非静态变量和非静态代码块(按先后顺序执行)； 子类构造器 //运行结果 this is person static block this is student static block hello person this person constructor hello student this student constructor 二、关键字final1)修饰变量—-&gt;常量​ 变量必须初始化，变量的值不允许修改。​ final变量都必须显示初始化，​ a) 修饰静态变量，只能在定义变量时进行初始化；​ b) 修饰实例变量，可以在定义变量时进行初始化，或者在构造方法中进行初始 化； 2)修饰方法​ 该方法不能够被重写 3)修饰类​ 该类不能够被继承,即不能与abstract同时使用。​ String类就是final修饰的类，所有字符串是不能改变的，只能通过拼接创建新的 String对象，这样很浪费内存，所以又有了StringBuilder和StringBuffer；这两 个类后面再解释，可以去思考和看他们的实现源码。 三、思考final、finally和finalize的区别 后面出一篇关于这个的文章，敬请关注。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—java关键字与数据类型]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94java%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[java关键字与数据类型 Java语言的关键字是程序代码中的特殊字符。包括： . 类和接口的声明——class, extends, implements, interface . 包引入和包声明——import, package . 数据类型——boolean, byte, char, double, float, int, long, short . 某些数据类型的可选值——false, true, null . 流程控制——break, case, continue, default, do, else, for, if, return, switch, while . 异常处理——catch, finally, throw, throws, try . 修饰符——abstract, final, native, private, protected, public, static, synchronized, transient, volatile . 操作符——instanceof . 创建对象——new . 引用——this, super . 方法返回类型——void . 所有关键字都是小写； . friendly, sizeof不是Java语言的关键字，但是保留字，也不能用来命名； . 程序中标识符不能以关键字命名； Java语言把数据类型分为基本类型和引用类型。 基本数据类型 数值类型 整数类型: byte,short,int,long 浮点数类型: float,double 布尔类型：boolean 字符类型：char 引用数据类型 类类型:比如String 接口类型 数组类型]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记系列整理说明]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%E6%95%B4%E7%90%86%E8%AF%B4%E6%98%8E.html</url>
    <content type="text"><![CDATA[java学习笔记系列整理说明​ 陆陆续续也巩固学习==java==基础也有一段时间了，这里整理了一些我认为比较的重要的知识点，供自己或者读者以后回顾和学习。这是一个学习笔记系列，有自己整理撰写的部分，也有很多老师分享的笔记和一些网上博客我认为写的很好讲解的很清晰的知识点，我只是动手去收集整理和分享了这样一份学习笔记。 ​ 整理这样一份学习笔记，方便别人也方便自己日后的复习回顾，可以说一举双得。同时，当自己去想要发表一篇学习笔记的时候，也会去认真的思考表达是否准确，归纳整理的是否全面，亦或是有无错误的地方，经过这样一轮的思考，自己也加深了对知识的理解，这也是我去整理这样一系列学习笔记的目的之一，别把学过的知识藏在电脑硬盘，学过后就不再点开。 ​ 都说基础比天大，是你搭建大厦的基石，有基础的支撑相信去理解一些高大上的框架等也会更加容易。这样一系列的==java==基础学习笔记，正好可以经常拿来浏览阅读。 ​ 最后，读者们有自己好的文章也可以互相添加友链，互相学习。有疑问或者在转载的文章中有侵犯您的权益，请及时联系我删除。 ​ 联系方式：chlinlearn@gmail.com]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—==与equals的区别]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94-%E4%B8%8Eequals%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[java学习笔记(基础篇)—==与equals的区别[TOC] 1.java数据类型分为:​ 基本数据类型​ 引用数据类型 2.对于”==”​ 用于基本数据类型相互比较. 比较二者的值是否相等​ 用于引用数据类型相互比较. 比较二者地址是否相等​ 不能用于基本数据类型与引用型比较 3.对于”equals”:​ 不能用于基本数据类型比较(因为这是一个方法, 继承自object).​ 用于进行对象的比较, 比较二者的引用地址是否相同 4.特殊情况:​ 1)数值型基本类型和数值型类会存在自动装箱和自动拆箱​ 2)字符串会以常量形式存在, 如果多个字符串变量值相同, 他们指向同一个地址，String类重写了equals()方法，比较的是内容是否相等。​ 3)数值类型会存在类型自动转换 5.关于重写equals​ 1）判断该对象是否是其本身：this==obj ​ 2）判断该对象是否为空：obj==null ​ 3）判断该对象是否和其属于同一类型：obj instanceof * 或者 obj.getClass == .class ​ 4）逐一比较，如全相同则是相等 6.思考​ 如果是HashMap又要如何重写呢？如何判断里面存储的对象是否相等？ 参考HashSet的实现源码。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—变量与表达式]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94%E5%8F%98%E9%87%8F%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content type="text"><![CDATA[java学习笔记(基础篇)—变量与表达式一：局部变量和实例变量 定义变量是指设定变量的数据类型和变量的名字，Java语言要求变量遵循先定义，再初始化，然后使用的规则。 作用域：指它的存在范围，只有在这个范围内，程序代码才能访问它。变量的生命周期是指从一个变量被创建并分配内存空间开始，到这个变量被销毁并清除其所占用内存空间的过程。 局部变量(参数变量也可以看成是局部变量)： 1)位置：定义在方法中或者在方法中的{} 2)使用：先赋值后使用 3)作用域：定义的方法中或者定义的{}中 4)生命周期：从变量的定义到方法调用结束 局部变量的例子：public void method1() { int a = 0; //局部变量，作用域为整个method01方法； { int b = 0; //局部变量，作用域为所处的代码块； b = a; } b = 20; //编译出错，b不能被访问； } 实例变量： 1)位置：定义方法外，类里面 2)使用：系统会进行默认初始化 3)作用域：作用于整个类 4)生命周期：从对象创建的时候到gc回收内存结束 实例变量的例子： class Test { private int n1=0; private int n2=0; public int add() { int result = n2 + n2; return result; } } 二：操作符: 操作符能与相应类型的数据组成表达式，来完成相应的运算。 a)数学运算操作符+数据类型值相加或字符串连接;System.out.println(1+2+"a"); //输出3a System.out.println(1+2.0+"a"); //输出3.0a System.out.println(1+2.0+"a"+true); //输出3.0atrue System.out.println("a"+1+2); //输出a12 System.out.println(1+"a"+2); //输出1a2 /整除, 如操作数均为整数，运算结果为商的整数部分int a1=12/5; //a1变量的取值为2 int a2=13/5; //a2变量的取值为2 int a3=-12/5; //a3变量的取值为-2 int a4=-13/5; //a4变量的取值为-2 int a5=1/5; //a5变量的取值为0 double a6=-12/5; //a6变量的取值为-2.0 double a7=-12/5.0; //a7变量的取值为-2.4 %取模操作符, 如操作数均为整数，运算结果为商的整数部分int a1=1%5; //a1变量的取值为1 int a2=13%5; //a2变量的取值为3 double a3=1%5; //a3变量的取值为1.0 double a4=12%5.1; //a4变量的取值为1.8000000000000007 /整除, 如操作数均为整数，运算结果为商的整数部分 int a1=12/5; //a1变量的取值为2 int a2=13/5; //a2变量的取值为2 int a3=-12/5; //a3变量的取值为-2 int a4=-13/5; //a4变量的取值为-2 int a5=1/5; //a5变量的取值为0 double a6=-12/5; //a6变量的取值为-2.0 double a7=-12/5.0; //a7变量的取值为-2.4 %取模操作符, 如操作数均为整数，运算结果为商的整数部分int a1=1%5; //a1变量的取值为1 int a2=13%5; //a2变量的取值为3 double a3=1%5; //a3变量的取值为1.0 double a4=12%5.1; //a4变量的取值为1.8000000000000007 b) 赋值操作符： = : int x=0,i=1,j=1; *=: 这里的"*="由操作符"*"和"="复合而成，它等价于 a=a*b,这种 复合操作符能使程序变得更加简洁。 /=: a/=b 等价于 a=a/b; %=: a%=b 等价于 a=a%b; 注意：+=和+的区别 如:short a=0; int b=123456; a+=b;和a=a+b;的区别: +=系统会进行隐式的数据类型转换，向=左边的数据类型进行转换。 a+b会向数据类型高的类型转换 c) 比较操作符 >大于 >= 大于等于 &lt; 小于 &lt;= 小于等于 以上操作符只适用于整数类型和浮点数类型； int a=1,b=1; double d=1.0; boolean result1 = a>b; //result1的值为false; boolean result2 = a&lt;b; //result2的值为false; boolean result3 = a>=d; //result3的值为true; boolean result4 = a&lt;=b; //result4的值为true; instanceof:判断一个引用类型所引用的对象是否是一个类的实例。该操作符左边是一个对象，右边是一个类名或接口名。形式如下： 如：String str="hello" System.out.println(str instanceof String); System.out.println(str instanceof Object); System.out.println(str instanceof Student); //false java.lang.Object是所有类的父类， 每一个类都会默认继承Object 子类是一个父类 是is a的关系 d)相等操作符== 等于!= 不等于既可以是基本类型，也可以是引用类型：基本数据类型比较是真正的数值引用类型比较的是地址，如果要比较引用类型真正的数据使用equals 如：int a=1,b=1; System.out.println(a==b); //输出true; 如：String s1="hello"; String s2="hello"; String s3=new String("hello"); String s4=new String("hello"); System.out.println(s1==s2); //true System.out.println(s3==s4); //false System.out.println(s1==s3); //false System.out.println(s3.equals(s4)); //true e) 移位操作符，针对二进制操作算术右移位运算，也称做带符号右移位运算。最高为补符号位。 > 逻辑右移位运算，也称为不带符号右移位运算。 > &lt;&lt; 左移位运算，也称为不带符号左移位运算。 f) 位运算操作符&amp;: 与运算，运算规则为：1&amp;1->1, 1&amp;0->0, 0&amp;1->0, 0&amp;0->0; |: 或运算，运算规则为：1|1->1, 1|0->1, 0|1->1, 0|0->0; ^: 异或运算，运算规则为：1^1->0, 1^0->1, 0^1->1, 0^0->0; 两个值相同为0,不同为1； ~ : 取反运算, ~1->0, ~0->1; 例如：8>>2====>8/2^2=2 8:0000...00001000 0000.........10 ====>2 8>>>3=====>8/2^3=1 8:0000...00001000 00000000.000001=====>1 8&lt;&lt;2======>8*2^2=32 8:0000...00001000 000000000100000======>32 1&amp;1=1 1&amp;0=0 0&amp;0=0 1|1=1 1|0=1 0|0=0 1^1=0 1^0=1 0^0=0 ~1=0 ~0=1 8&amp;2=0 8|2=10 8^2=10 ~8= ~2= 1010 10===>第三位置1===>14 10===>第二位清0===>8 10===>第一位置反===>11 10===>输出相应的二进制 f) 逻辑操作符短路操作符: 如果能根据操作左边的布尔表达式就能推算出整个表达式的布尔值，将不执行操作符右边的布尔表达式； &amp;&amp;:左边的布尔表达式的值为false, 整个表达式值肯定为false, 此时会忽略执行右边的布尔表达式。 ||:左边的布尔表达式的值为true, 整个表达式值肯定为true, 此时会忽略执行右边的布尔表达式。 if(条件1&amp;&amp;条件2){} if条件1为假，不会执行条件2 if条件1为真，会执行条件2 if(条件1||条件2){} if条件1为真，不会执行条件2 if条件1为假，会执行条件2 g) 条件操作符布尔表达式 ? 表达式1 : 表达式2 如果布尔表达式的值为true,就返回表达式1的值,否则返回表达式2的值。 int score = 61; String result = score>=60?"及格":"不及格"; h)++,-- 前++与后++ 前--与后-- int a=10; b=++a =====>a=11,b=11,先计算，后赋值 b=a++ =====>a=11,b=10，先赋值，后计算 System.out.println("a:"+a+" b:"+b); 三.数据类型的转换1）基本数据类型转换隐式的数据类型转换：精度小的数据给精度大的数据 强制（显式）的数据类型转换：(type)精度大的数据给精度小的数据 System.out.println((int)(char)(byte)-1); 数据类型在转换的时候注意： a)如果将精度小的数据转为精度大的数据时。 如果转之前是有符号数，在前面补符号位 如果转之前是无符号数，在前面补0 b)如果将精度大的数据转为精度小的数据时。 从低位窃取位数 2）引用数据类型转换隐式的数据类型转换：子类转换父类 强制（显式）的数据类型转换：父类转换子类 String str="hello"; Object o=str; String str2=(String)o;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—java数组]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94java%E6%95%B0%E7%BB%84.html</url>
    <content type="text"><![CDATA[java数组一：什么是数组，什么时候使用数组？ 数组是用来保存一组数据类型相同的元素的有序集合，数组中的每个数据称为元素。有序集合可以按照顺序或者下标取数组中的元素。 在Java中，数组也是Java对象。数组中的元素可以是任意类型(包括基本类型和引用类),但同一个数组里只能存放类型相同的元素。 二：什么时候用数组？ 保存一堆数据类型相同的数据的时候。 数据要求有顺序。 三：数组和链表的区别 在内存开辟难易程度上？ 数组内存分配必须是一块连续的内存空间。 链表内存分配不一定是连续的内存空间。 在项目中如何选择？项目重点在数据的增删改，选择链表。不需要数据的大量搬移 项目重点在数据的查询，选择数组，检索效率非常高。 四：创建数组大致包括如下步骤： 声明一个数组类型的引用变量，简称为数组变量； 用new语句构造数组的实例。new语句为数组分配内存，并且为数组中的每个元素赋予默认值； 初始化，即为数组的每个元素设置合适的初始值。 1. a)数组变量的声明； 1) 一个存放同一类型数据的集合 a. 即可以是基本类型，也可以是对象类型； b. 数组中的每个数据为元素； 2) 数组是一个对象，成员是数组长度和数组中的元素; 3) 申明了一个数组变量并不是创建了一个对象; 4) 申明数组的方式; int[] IArray 或者 int IArray[] 基本数据类型数组，数组中存放的是基本数据类型。 Teacher[] tArray 或者 Teacher tArray[]类数组， 数组中存放的是Teacher类创建的若干个的对象。 注意：1) 声明数组变量的时侯，不能指定数组的长度，以下声明方式是非法的。 int x[1]; int[2] x; b)初始化数组 初始化：自变量创建后首次赋值的过程； 创建数组对象；数组对象和其他Java对象一样，也用new语句创建； int[] iArray = new int[2]; new语句执行以下步骤： a. 在堆区中为数组分配内存空间，以上代码创建了一个包含2个元素的int数组； 每个元素都是int类型，占4个字节，因此整个数组对象在内存中占用8个字节。 b. 为数组中的每个元素赋予其数据类型的默认值。 byte/short/int/long 0 float 0.0f double 0.0d String null char '\u0000' boolean false c. 返回数组对象的引用 c)初始化数组对象； 数组中的每个元素都有一个索引，或者称为下标。 数组中的第一个元素的索引为0，第二个元素的索引为1, 依次类推。 通过索引可以访问数组中的元素或者给数组中元素内容赋值。 1) 声明、创建、初始化分开： int[] iArray; iArray = new int[2]; iArray[0] = 0; iArray[1] = 1; 2) 声明、创建的同时并初始化数组； int[] iArray = {0, 1}; Student sArray[] = new Student[] { new Student(“George”, “Male”, 20), new Student()}; Student[] stArray = { new Student(), new Student()} ; 注意：a. 非法的数组初始化方式： int[] x = new int[5]{5,4,3,2,1};//编译出错，不能在[]中指定数组的长度； int[] x; x = {5,4,3,2,1}; //{5,4,3,2,1}必须在声明数组变量的语句中使用，不能单独使用 五. 数组的边界： 一个数组的下标从0开始，数组通过数组的对象引用变量的下标访问数组。数组中第一个元素的索引为0, 第二元素的索引为1，依次类推。如果一个数组长度是5，要访问最后一个数组元素可以通过下标4来访问，如果通过下标5访问，超出了数组的边界，在运行时会抛出 ArrayIndexOutOfBoundsException。 通过调用数组的length方法可以获得一个数组的元素个数（数组长度）。 所有Java数组都有一个length属性，表示数组的长度. 该属性只能读取，但是不能修改。 六：二维数组 存放一维数组的数组 int[][] a = new int[2][3]; a[0].length; a.length; 七：System.arraycopy()​ 数组的长度一旦定义了，就无法修改。所以需要arraycopy()来重新分配一个新的 数组(扩容)，然后将其内容拷贝进去。 int[] a = new int[5]; int[] b = new int[5]; a=b与System.arraycopy(a,0,b,0,5)有什么区别？ /* * @param src the source array. * @param srcPos starting position in the source array. * @param dest the destination array. * @param destPos starting position in the destination data. * @param length the number of array elements to be copied. */ public static native void arraycopy(Object src, int srcPos,Object dest, int destPos,int length); 八：可变长参数 ... 参数的个数可变两个int相加? public int add(int a,int b){} 三个int相加? public int add(int a,int b,int c){} 四个int相加? public int add(int a,int b,int c,int d){} 五个int相加? public int add(int a,int b,int c,int d,int e){} .......... 上面的方案代码非常冗余。类似的代码重复写。 jdk1.5之前的解决方案：通过数组解决的 public int add(int[] a){ } add(new int[]{5,8,9}); add(new int[]{5,8}); 缺点:每次都要创建新的数组， 创建数组需要在堆区开辟连续的内存空间。 参数调用之后该变量就没用了，这样会 浪费内存空间。 jdk1.5之后的解决方案：通过...解决的 public int add(int... a){ } 调用: add(1,4); add(1,4,6); add(7,6,8,89,76); 注意:1)可变长参数的使用和数组的使用是一样。 2)一个方法中只能定义一个可变长参数,并且要定义最后一个参数。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—抽象与接口的区别]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94%E6%8A%BD%E8%B1%A1%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[抽象与接口的区别一、抽象(abstract) 1. 抽象方法 1) 作用：定义规范 2) 抽象方法用来描述具有什么功能，但不提供实现。 3) 如果类中一个方法没有实现就要定义一个抽象方法。 2. 抽象类 1）如果类中有抽象方法，该类就必须定义为抽象类。 2）抽象类中不一定有抽象方法，可以包含普通方法、实例变量、构造器；但没有抽象构造器和抽象静态方法。 3）抽象类失去了创建对象的能力，只能提供给子类继承。 4）继承抽象类必须实现其所有的抽象方法，或者子类也定义为抽象类。 5）抽象类和抽象方法不能被final修饰。 二、接口(interface) 1. 接口 1）作用：定义规范，解决多继承问题。 多继承的不足之处：造成代码浪费，引发继承的多义性（即多个父类中可能含有几个命名相同的方法或属性，调用时就不知道使用的是来自哪里） 2）接口是抽象类的抽象，接口的方法都是抽象方法，默认都是public abstract类型。 3）接口的成员变量默认都是常量，被public final static 修饰。 4）接口没有构造器，不能被实例化。 5）接口可以继承多个接口，一个类也可以实现多个接口，达到解决多继承的目的。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—数组模拟实现栈]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%A0%88.html</url>
    <content type="text"><![CDATA[栈的概念 先进后出策略(LIFO) 是一种基本数据结构 栈的分类有两种：1.静态栈（数组实现） 2.动态栈（链表实现） 栈的模型图如下： 需求分析在编写代码之前，我习惯先对要实现的程序进行需求分析，比如用什么数据结构存储数据，需要实现哪些基本的功能等。这次是通过数组模拟实现栈，所以是一个==静态栈==，但是我在栈满时通过arraycopy函数自动扩容，后面会细说。我们要实现的功能至少应该包含以下功能： public class Stack { private int[] array;//模拟栈 private int length = 0;//栈总长度 private int size = 0;//栈存在元素个数 public Stack() { this(10); } public Stack(int length) { array = new int[length]; this.length = length; } //入栈 public void push(int num) {} //出栈 public int pop() {} //栈是否为空 public boolean isEmpty() {} //栈是否已满,已满则每次扩容5个单位 public boolean isFull() {} //清除栈所有元素 public void removeAll() {} //获取栈内存在元素个数 public int getSize() {} //获取栈的总长度 public int getLength() {} } 具体实现 入栈push()首先判断当前栈是否已满，如果已满则扩容；此时栈内存在元素size增加1。 //入栈 public void push(int num) { isFull(); array[length-1-size] = num; size++; } 出栈pop()判断当前栈是否为空，为空则返回0；不为空，将数组中最靠近下标0的非0元素置0；此时栈内元素size减1，并返回出栈的值； //出栈 public int pop() { if(isEmpty()) { return 0; } int result = 0; for (int i = 0; i &lt; array.length; i++) { if (array[i]==0) { continue; } result = array[i]; array[i] = 0; size--; break; } return result; } 栈是否为空isEmpty() //栈是否为空 public boolean isEmpty() { if(size==0) { System.out.println("栈为空！"); return true; } return false; } 栈是否已满,已满则每次扩容5个单位isFull()如果栈内存在的元素个数等于数组长度，则表示栈已满；通过new一个新的更大的数组，调用arraycopy方法将b的引用赋给array，并且数组的长度也要加长。arraycopy()的参数含义如下： /** * 参数含义 * @param src 原数组对象的引用 * @param srcPos 原数组要拷贝的数据的原始位置 * @param dest 目标数组对象的引用 * @param destPos 目标数组要拷贝的数据的原始位置 * @param length 原数组要拷贝的长度 */ public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); //栈是否已满,已满则每次扩容5个单位 public boolean isFull() { if (size==length) { //System.out.println("当前栈已满，扩容5个单位。"); int[] b = new int[length+5]; System.arraycopy(array, 0, b, 5, length); array = b; this.length += 5; return true; } return false; } 清除栈所有元素removeAll()清除所有元素就是遍历一遍数组，将全部元素的值置0； //清除栈所有元素 public void removeAll() { for (int i = 0; i &lt; array.length; i++) { if (array[i]!=0) { array[i] = 0; size--; } } } 获取栈内存在元素个数getSize() //获取栈内存在元素个数 public int getSize() { return size; } 获取栈的总长度getLength() //获取栈的总长度 public int getLength() { return length; } 测试public class StackTest { public static void main(String[] args) { //创建一个默认长度为10的栈 Stack stack = new Stack(2); //入栈 stack.push(10); stack.push(9); stack.push(8); System.out.println("当前栈元素个数:"+stack.getSize()); System.out.println("当前栈的总长度:"+stack.getLength()); stack.printStack(); //出栈 int p = stack.pop(); System.out.println("当前出栈元素的值:"+p); System.out.println("当前栈元素个数:"+stack.getSize()); System.out.println("当前栈的总长度:"+stack.getLength()); stack.printStack(); //清空栈 stack.removeAll(); //stack.isEmpty(); int p2 = stack.pop(); System.out.println("当前出栈元素的值:"+p2); System.out.println("当前栈元素个数:"+stack.getSize()); System.out.println("当前栈的总长度:"+stack.getLength()); } } 测试结果： 当前栈元素个数:3 当前栈的总长度:7 当前栈情况:8 9 10 当前出栈元素的值:8 当前栈元素个数:2 当前栈的总长度:7 当前栈情况:9 10 栈为空！ 当前出栈元素的值:0 当前栈元素个数:0 当前栈的总长度:7 欢迎访问我的个人网站www.chlinlearn.cn到这里就要结束了，后续如果有时间也会出一篇链表实现栈的文章，欢迎来访问我的个人网站，最新文章都会首先在那里发布哦^^]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现DFA模拟程序]]></title>
    <url>%2Fpython%E5%AE%9E%E7%8E%B0dfa%E6%A8%A1%E6%8B%9F%E7%A8%8B%E5%BA%8F.html</url>
    <content type="text"><![CDATA[DFA（确定的有穷自动机）一个确定的有穷自动机M是一个五元组： M=(K，∑，f，S，Z) K是一个有穷集，它的每个元素称为一个状态。 ∑是一个有穷字母表，它的每一个元素称为一个输入符号，所以也陈∑为输入符号表。 f是转换函数，是Kx∑-&gt;K上的映象。 S∈K，是唯一的一个初态。 Z∈K，是一个终态集，终态也称可接受状态或结束状态。 实例代码 实现文法 G[S]: S->aU|bV U->bV|aQ Q->aQ|bQ 状态图 代码实现 -*- coding: utf-8 -*- # #@author: chlinlearn #@createTime: 2019/4/13 14:12 #@fileName: DFA class DFA(): def __init__(self): #状态集 self.listEdge = [] #初态 self.S = [] #终态 self.Z = [] #判断是否是终态集 def isZ(self,ch): for i in range(0,len(self.Z)) : if self.Z[0] == ch or self.Z[1] == ch: return True else: return False #输入 def input(self): self.S = input("请输入开始符：") self.Z = input("请输入终态集(终集符组成的一个字符串)：") self.Z = self.Z.split(",") print("请输入正规文法以exit结尾：") print("example:S,aZ") while(True): list = [] inStr = input() if inStr=='exit': break inStr = inStr.split(',') # 读取第一个状态集 s = inStr[0] for i in range(0,len(inStr[1])): #ch,ns if len(inStr[1])==2: c = inStr[1][0] n = inStr[1][1] list = [s,c,n] self.listEdge.append(list) elif len(inStr[1])==1: c = inStr[1][0] list = [s, c, self.Z[0]] self.listEdge.append(list) #转换函数 def isNextState(self,s,ch): for i in range(0,len(self.listEdge)): if s == self.listEdge[i][0] and ch == self.listEdge[i][1]: return self.listEdge[i][2] return def judgeDFA(self): print("请输入要判断的字符串:") while(True): #获取字母表 str = input() if '#' in str : print("程序已退出，欢迎下次使用!") return temp = self.S[0] for i in range(0,len(str)): if str[i] is 'a': temp = self.isNextState(temp,'a') elif str[i] is 'b': temp = self.isNextState(temp, 'b') else: break if self.isZ(temp): print("此字符串“属于”该文法！") else: print("此字符串“不属于”该文法！") print("再次判断请输入字符串(退出程序输入#):") if __name__ == '__main__': DFA = DFA() DFA.input() DFA.judgeDFA() 总结这是我在课程中的一个实验，代码手写并且可运行，是参照一个java版的代码实现的，加上自己的理解和思路把它以python的形式实现。学习别人好的地方，当然也不能照搬别人，不然能够为己用的东西少之又少。通过不同的编程语言把整个思路在理一遍能够加深自己的理解，并且能够得到一样的运行结果，说明自己的理解是对的。最后也附上对应的java版代码，有需求的童鞋可以参考喔！欢迎访问我的个人网站www.chlinlearn.cn 附件java版DFA import java.util.ArrayList; import java.util.List; import java.util.Scanner; class edge { char PriorityState; char ch; char NextState; edge(char p,char c, char n){ PriorityState = p; ch = c; NextState = n; } @Override public String toString() { return "edge [PriorityState=" + PriorityState + ", ch=" + ch + ", NextState=" + NextState + "]"; } } /**DFA的构造*/ public class DFA { static List&lt;edge> listEdge = new ArrayList&lt;edge>();//状态集 //static HashMap&lt;edge, Character> mapEdge = new HashMap&lt;>(); static String S;//初态集 static String Z;//终态集 //flag is here static boolean judeZ(char ch){ for(int j=0; j&lt;Z.length(); j++){ if(Z.charAt(j)==ch) return true; } return false; } static void input() { Scanner in = new Scanner(System.in); String instr = null; String subStr[] = null; System.out.println("请输入开始符："); S = in.next(); System.out.println("请输入终态集(终集符组成的一个字符串)："); Z = in.next(); System.out.println("请输入正规文法以end结尾(形式如下图)："); System.out.println("----------"); System.out.println("| S-aU |"); System.out.println("| S-bV |"); System.out.println("| U-bV |"); System.out.println("| .... |"); System.out.println("| end |"); System.out.println("----------"); while(in.hasNext()){ instr = in.next(); if("end".equals(instr)) break; subStr = instr.split("-|\\|");//连字符 System.out.println("subStr:"+subStr); String s = subStr[0];//读取一行f(转换函数) System.out.println(s); for(int i=1; i&lt;subStr.length; i++){ edge e = null; System.out.println(subStr[1]); if(subStr[i].length()==2){ char c = subStr[i].charAt(0);//字母表 char n = subStr[i].charAt(1);//状态集 listEdge.add(new edge(s.charAt(0),c,n));//f(S,a)=U } if(subStr[i].length()==1){ char c = subStr[i].charAt(0); listEdge.add(new edge(s.charAt(0),c,Z.charAt(0))); } } } } static char judeNextState(char s,char ch){ for(int i=0; i&lt;listEdge.size(); i++){ if(s==listEdge.get(i).PriorityState &amp;&amp; ch==listEdge.get(i).ch){ return listEdge.get(i).NextState; } } return '0'; } static void judeDFA(){ Scanner in = new Scanner(System.in); System.out.println("请输入要判断的字符串:"); while(in.hasNext()){ String str = in.next(); if(str.equals("#")){ System.out.println("程序已退出，欢迎下次使用!"); return; } char temp = S.charAt(0); int i=0; //System.out.println(temp+" "+mapEdge.get(e)); for(; i&lt;str.length(); i++){ //System.out.println("temp="+temp); if(str.charAt(i)=='a'){ temp = judeNextState(temp, 'a'); } else if(str.charAt(i)=='b'){ temp = judeNextState(temp, 'b'); } else break; } //flag is here if(i>=str.length() &amp;&amp; judeZ(temp)) System.out.println("此字符串“属于”该文法！"); else System.out.println("此字符串“不属于”该文法！"); System.out.println("再次判断请输入字符串(退出程序输入#):"); } } /*main*/ public static void main(String[] args) { // TODO Auto-generated method stub DFA.input(); DFA.judeDFA(); } }]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>DFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新篇章]]></title>
    <url>%2F%E6%96%B0%E7%AF%87%E7%AB%A0.html</url>
    <content type="text"><![CDATA[hi,大家好！准备了好久，下了很大的决心，终于可以开始更博啦！]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
</search>
