<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—java关键字与数据类型]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94java%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[java关键字与数据类型 Java语言的关键字是程序代码中的特殊字符。包括： . 类和接口的声明——class, extends, implements, interface . 包引入和包声明——import, package . 数据类型——boolean, byte, char, double, float, int, long, short . 某些数据类型的可选值——false, true, null . 流程控制——break, case, continue, default, do, else, for, if, return, switch, while . 异常处理——catch, finally, throw, throws, try . 修饰符——abstract, final, native, private, protected, public, static, synchronized, transient, volatile . 操作符——instanceof . 创建对象——new . 引用——this, super . 方法返回类型——void . 所有关键字都是小写； . friendly, sizeof不是Java语言的关键字，但是保留字，也不能用来命名； . 程序中标识符不能以关键字命名； Java语言把数据类型分为基本类型和引用类型。 基本数据类型 数值类型 整数类型: byte,short,int,long 浮点数类型: float,double 布尔类型：boolean 字符类型：char 引用数据类型 类类型:比如String 接口类型 数组类型]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—==与equals的区别]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94-%E4%B8%8Eequals%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[java学习笔记(基础篇)—==与equals的区别[TOC] 1.java数据类型分为:​ 基本数据类型​ 引用数据类型 2.对于”==”​ 用于基本数据类型相互比较. 比较二者的值是否相等​ 用于引用数据类型相互比较. 比较二者地址是否相等​ 不能用于基本数据类型与引用型比较 3.对于”equals”:​ 不能用于基本数据类型比较(因为这是一个方法, 继承自object).​ 用于进行对象的比较, 比较二者的引用地址是否相同 4.特殊情况:​ 1)数值型基本类型和数值型类会存在自动装箱和自动拆箱​ 2)字符串会以常量形式存在, 如果多个字符串变量值相同, 他们指向同一个地址，String类重写了equals()方法，比较的是内容是否相等。​ 3)数值类型会存在类型自动转换 5.关于重写equals​ 1）判断该对象是否是其本身：this==obj ​ 2）判断该对象是否为空：obj==null ​ 3）判断该对象是否和其属于同一类型：obj instanceof * 或者 obj.getClass == .class ​ 4）逐一比较，如全相同则是相等 6.思考​ 如果是HashMap又要如何重写呢？如何判断里面存储的对象是否相等？ 参考HashSet的实现源码。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—java数组]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94java%E6%95%B0%E7%BB%84.html</url>
    <content type="text"><![CDATA[java数组一：什么是数组，什么时候使用数组？ 数组是用来保存一组数据类型相同的元素的有序集合，数组中的每个数据称为元素。有序集合可以按照顺序或者下标取数组中的元素。 在Java中，数组也是Java对象。数组中的元素可以是任意类型(包括基本类型和引用类),但同一个数组里只能存放类型相同的元素。 二：什么时候用数组？ 保存一堆数据类型相同的数据的时候。 数据要求有顺序。 三：数组和链表的区别 在内存开辟难易程度上？ 数组内存分配必须是一块连续的内存空间。 链表内存分配不一定是连续的内存空间。 在项目中如何选择？项目重点在数据的增删改，选择链表。不需要数据的大量搬移 项目重点在数据的查询，选择数组，检索效率非常高。 四：创建数组大致包括如下步骤： 声明一个数组类型的引用变量，简称为数组变量； 用new语句构造数组的实例。new语句为数组分配内存，并且为数组中的每个元素赋予默认值； 初始化，即为数组的每个元素设置合适的初始值。 1. a)数组变量的声明； 1) 一个存放同一类型数据的集合 a. 即可以是基本类型，也可以是对象类型； b. 数组中的每个数据为元素； 2) 数组是一个对象，成员是数组长度和数组中的元素; 3) 申明了一个数组变量并不是创建了一个对象; 4) 申明数组的方式; int[] IArray 或者 int IArray[] 基本数据类型数组，数组中存放的是基本数据类型。 Teacher[] tArray 或者 Teacher tArray[]类数组， 数组中存放的是Teacher类创建的若干个的对象。 注意：1) 声明数组变量的时侯，不能指定数组的长度，以下声明方式是非法的。 int x[1]; int[2] x; b)初始化数组 初始化：自变量创建后首次赋值的过程； 创建数组对象；数组对象和其他Java对象一样，也用new语句创建； int[] iArray = new int[2]; new语句执行以下步骤： a. 在堆区中为数组分配内存空间，以上代码创建了一个包含2个元素的int数组； 每个元素都是int类型，占4个字节，因此整个数组对象在内存中占用8个字节。 b. 为数组中的每个元素赋予其数据类型的默认值。 byte/short/int/long 0 float 0.0f double 0.0d String null char '\u0000' boolean false c. 返回数组对象的引用 c)初始化数组对象； 数组中的每个元素都有一个索引，或者称为下标。 数组中的第一个元素的索引为0，第二个元素的索引为1, 依次类推。 通过索引可以访问数组中的元素或者给数组中元素内容赋值。 1) 声明、创建、初始化分开： int[] iArray; iArray = new int[2]; iArray[0] = 0; iArray[1] = 1; 2) 声明、创建的同时并初始化数组； int[] iArray = {0, 1}; Student sArray[] = new Student[] { new Student(“George”, “Male”, 20), new Student()}; Student[] stArray = { new Student(), new Student()} ; 注意：a. 非法的数组初始化方式： int[] x = new int[5]{5,4,3,2,1};//编译出错，不能在[]中指定数组的长度； int[] x; x = {5,4,3,2,1}; //{5,4,3,2,1}必须在声明数组变量的语句中使用，不能单独使用 五. 数组的边界： 一个数组的下标从0开始，数组通过数组的对象引用变量的下标访问数组。数组中第一个元素的索引为0, 第二元素的索引为1，依次类推。如果一个数组长度是5，要访问最后一个数组元素可以通过下标4来访问，如果通过下标5访问，超出了数组的边界，在运行时会抛出 ArrayIndexOutOfBoundsException。 通过调用数组的length方法可以获得一个数组的元素个数（数组长度）。 所有Java数组都有一个length属性，表示数组的长度. 该属性只能读取，但是不能修改。 六：二维数组 存放一维数组的数组 int[][] a = new int[2][3]; a[0].length; a.length; 七：System.arraycopy()​ 数组的长度一旦定义了，就无法修改。所以需要arraycopy()来重新分配一个新的 数组(扩容)，然后将其内容拷贝进去。 int[] a = new int[5]; int[] b = new int[5]; a=b与System.arraycopy(a,0,b,0,5)有什么区别？ /* * @param src the source array. * @param srcPos starting position in the source array. * @param dest the destination array. * @param destPos starting position in the destination data. * @param length the number of array elements to be copied. */ public static native void arraycopy(Object src, int srcPos,Object dest, int destPos,int length); 八：可变长参数 ... 参数的个数可变两个int相加? public int add(int a,int b){} 三个int相加? public int add(int a,int b,int c){} 四个int相加? public int add(int a,int b,int c,int d){} 五个int相加? public int add(int a,int b,int c,int d,int e){} .......... 上面的方案代码非常冗余。类似的代码重复写。 jdk1.5之前的解决方案：通过数组解决的 public int add(int[] a){ } add(new int[]{5,8,9}); add(new int[]{5,8}); 缺点:每次都要创建新的数组， 创建数组需要在堆区开辟连续的内存空间。 参数调用之后该变量就没用了，这样会 浪费内存空间。 jdk1.5之后的解决方案：通过...解决的 public int add(int... a){ } 调用: add(1,4); add(1,4,6); add(7,6,8,89,76); 注意:1)可变长参数的使用和数组的使用是一样。 2)一个方法中只能定义一个可变长参数,并且要定义最后一个参数。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记系列整理说明]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%E6%95%B4%E7%90%86%E8%AF%B4%E6%98%8E.html</url>
    <content type="text"><![CDATA[java学习笔记系列整理说明​ 陆陆续续也巩固学习==java==基础也有一段时间了，这里整理了一些我认为比较的重要的知识点，供自己或者读者以后回顾和学习。这是一个学习笔记系列，有自己整理撰写的部分，也有很多老师分享的笔记和一些网上博客我认为写的很好讲解的很清晰的知识点，我只是动手去收集整理和分享了这样一份学习笔记。 ​ 整理这样一份学习笔记，方便别人也方便自己日后的复习回顾，可以说一举双得。同时，当自己去想要发表一篇学习笔记的时候，也会去认真的思考表达是否准确，归纳整理的是否全面，亦或是有无错误的地方，经过这样一轮的思考，自己也加深了对知识的理解，这也是我去整理这样一系列学习笔记的目的之一，别把学过的知识藏在电脑硬盘，学过后就不再点开。 ​ 都说基础比天大，是你搭建大厦的基石，有基础的支撑相信去理解一些高大上的框架等也会更加容易。这样一系列的==java==基础学习笔记，正好可以经常拿来浏览阅读。 ​ 最后，读者们有自己好的文章也可以互相添加友链，互相学习。有疑问或者在转载的文章中有侵犯您的权益，请及时联系我删除。 ​ 联系方式：chlinlearn@gmail.com]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—变量与表达式]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94%E5%8F%98%E9%87%8F%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content type="text"><![CDATA[java学习笔记(基础篇)—变量与表达式一：局部变量和实例变量 定义变量是指设定变量的数据类型和变量的名字，Java语言要求变量遵循先定义，再初始化，然后使用的规则。 作用域：指它的存在范围，只有在这个范围内，程序代码才能访问它。变量的生命周期是指从一个变量被创建并分配内存空间开始，到这个变量被销毁并清除其所占用内存空间的过程。 局部变量(参数变量也可以看成是局部变量)： 1)位置：定义在方法中或者在方法中的{} 2)使用：先赋值后使用 3)作用域：定义的方法中或者定义的{}中 4)生命周期：从变量的定义到方法调用结束 局部变量的例子：public void method1() { int a = 0; //局部变量，作用域为整个method01方法； { int b = 0; //局部变量，作用域为所处的代码块； b = a; } b = 20; //编译出错，b不能被访问； } 实例变量： 1)位置：定义方法外，类里面 2)使用：系统会进行默认初始化 3)作用域：作用于整个类 4)生命周期：从对象创建的时候到gc回收内存结束 实例变量的例子： class Test { private int n1=0; private int n2=0; public int add() { int result = n2 + n2; return result; } } 二：操作符: 操作符能与相应类型的数据组成表达式，来完成相应的运算。 a)数学运算操作符+数据类型值相加或字符串连接;System.out.println(1+2+"a"); //输出3a System.out.println(1+2.0+"a"); //输出3.0a System.out.println(1+2.0+"a"+true); //输出3.0atrue System.out.println("a"+1+2); //输出a12 System.out.println(1+"a"+2); //输出1a2 /整除, 如操作数均为整数，运算结果为商的整数部分int a1=12/5; //a1变量的取值为2 int a2=13/5; //a2变量的取值为2 int a3=-12/5; //a3变量的取值为-2 int a4=-13/5; //a4变量的取值为-2 int a5=1/5; //a5变量的取值为0 double a6=-12/5; //a6变量的取值为-2.0 double a7=-12/5.0; //a7变量的取值为-2.4 %取模操作符, 如操作数均为整数，运算结果为商的整数部分int a1=1%5; //a1变量的取值为1 int a2=13%5; //a2变量的取值为3 double a3=1%5; //a3变量的取值为1.0 double a4=12%5.1; //a4变量的取值为1.8000000000000007 /整除, 如操作数均为整数，运算结果为商的整数部分 int a1=12/5; //a1变量的取值为2 int a2=13/5; //a2变量的取值为2 int a3=-12/5; //a3变量的取值为-2 int a4=-13/5; //a4变量的取值为-2 int a5=1/5; //a5变量的取值为0 double a6=-12/5; //a6变量的取值为-2.0 double a7=-12/5.0; //a7变量的取值为-2.4 %取模操作符, 如操作数均为整数，运算结果为商的整数部分int a1=1%5; //a1变量的取值为1 int a2=13%5; //a2变量的取值为3 double a3=1%5; //a3变量的取值为1.0 double a4=12%5.1; //a4变量的取值为1.8000000000000007 b) 赋值操作符： = : int x=0,i=1,j=1; *=: 这里的"*="由操作符"*"和"="复合而成，它等价于 a=a*b,这种 复合操作符能使程序变得更加简洁。 /=: a/=b 等价于 a=a/b; %=: a%=b 等价于 a=a%b; 注意：+=和+的区别 如:short a=0; int b=123456; a+=b;和a=a+b;的区别: +=系统会进行隐式的数据类型转换，向=左边的数据类型进行转换。 a+b会向数据类型高的类型转换 c) 比较操作符 >大于 >= 大于等于 &lt; 小于 &lt;= 小于等于 以上操作符只适用于整数类型和浮点数类型； int a=1,b=1; double d=1.0; boolean result1 = a>b; //result1的值为false; boolean result2 = a&lt;b; //result2的值为false; boolean result3 = a>=d; //result3的值为true; boolean result4 = a&lt;=b; //result4的值为true; instanceof:判断一个引用类型所引用的对象是否是一个类的实例。该操作符左边是一个对象，右边是一个类名或接口名。形式如下： 如：String str="hello" System.out.println(str instanceof String); System.out.println(str instanceof Object); System.out.println(str instanceof Student); //false java.lang.Object是所有类的父类， 每一个类都会默认继承Object 子类是一个父类 是is a的关系 d)相等操作符== 等于!= 不等于既可以是基本类型，也可以是引用类型：基本数据类型比较是真正的数值引用类型比较的是地址，如果要比较引用类型真正的数据使用equals 如：int a=1,b=1; System.out.println(a==b); //输出true; 如：String s1="hello"; String s2="hello"; String s3=new String("hello"); String s4=new String("hello"); System.out.println(s1==s2); //true System.out.println(s3==s4); //false System.out.println(s1==s3); //false System.out.println(s3.equals(s4)); //true e) 移位操作符，针对二进制操作算术右移位运算，也称做带符号右移位运算。最高为补符号位。 > 逻辑右移位运算，也称为不带符号右移位运算。 > &lt;&lt; 左移位运算，也称为不带符号左移位运算。 f) 位运算操作符&amp;: 与运算，运算规则为：1&amp;1->1, 1&amp;0->0, 0&amp;1->0, 0&amp;0->0; |: 或运算，运算规则为：1|1->1, 1|0->1, 0|1->1, 0|0->0; ^: 异或运算，运算规则为：1^1->0, 1^0->1, 0^1->1, 0^0->0; 两个值相同为0,不同为1； ~ : 取反运算, ~1->0, ~0->1; 例如：8>>2====>8/2^2=2 8:0000...00001000 0000.........10 ====>2 8>>>3=====>8/2^3=1 8:0000...00001000 00000000.000001=====>1 8&lt;&lt;2======>8*2^2=32 8:0000...00001000 000000000100000======>32 1&amp;1=1 1&amp;0=0 0&amp;0=0 1|1=1 1|0=1 0|0=0 1^1=0 1^0=1 0^0=0 ~1=0 ~0=1 8&amp;2=0 8|2=10 8^2=10 ~8= ~2= 1010 10===>第三位置1===>14 10===>第二位清0===>8 10===>第一位置反===>11 10===>输出相应的二进制 f) 逻辑操作符短路操作符: 如果能根据操作左边的布尔表达式就能推算出整个表达式的布尔值，将不执行操作符右边的布尔表达式； &amp;&amp;:左边的布尔表达式的值为false, 整个表达式值肯定为false, 此时会忽略执行右边的布尔表达式。 ||:左边的布尔表达式的值为true, 整个表达式值肯定为true, 此时会忽略执行右边的布尔表达式。 if(条件1&amp;&amp;条件2){} if条件1为假，不会执行条件2 if条件1为真，会执行条件2 if(条件1||条件2){} if条件1为真，不会执行条件2 if条件1为假，会执行条件2 g) 条件操作符布尔表达式 ? 表达式1 : 表达式2 如果布尔表达式的值为true,就返回表达式1的值,否则返回表达式2的值。 int score = 61; String result = score>=60?"及格":"不及格"; h)++,-- 前++与后++ 前--与后-- int a=10; b=++a =====>a=11,b=11,先计算，后赋值 b=a++ =====>a=11,b=10，先赋值，后计算 System.out.println("a:"+a+" b:"+b); 三.数据类型的转换1）基本数据类型转换隐式的数据类型转换：精度小的数据给精度大的数据 强制（显式）的数据类型转换：(type)精度大的数据给精度小的数据 System.out.println((int)(char)(byte)-1); 数据类型在转换的时候注意： a)如果将精度小的数据转为精度大的数据时。 如果转之前是有符号数，在前面补符号位 如果转之前是无符号数，在前面补0 b)如果将精度大的数据转为精度小的数据时。 从低位窃取位数 2）引用数据类型转换隐式的数据类型转换：子类转换父类 强制（显式）的数据类型转换：父类转换子类 String str="hello"; Object o=str; String str2=(String)o;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—抽象与接口的区别]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94%E6%8A%BD%E8%B1%A1%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[抽象与接口的区别一、抽象(abstract) 1. 抽象方法 1) 作用：定义规范 2) 抽象方法用来描述具有什么功能，但不提供实现。 3) 如果类中一个方法没有实现就要定义一个抽象方法。 2. 抽象类 1）如果类中有抽象方法，该类就必须定义为抽象类。 2）抽象类中不一定有抽象方法，可以包含普通方法、实例变量、构造器；但没有抽象构造器和抽象静态方法。 3）抽象类失去了创建对象的能力，只能提供给子类继承。 4）继承抽象类必须实现其所有的抽象方法，或者子类也定义为抽象类。 5）抽象类和抽象方法不能被final修饰。 二、接口(interface) 1. 接口 1）作用：定义规范，解决多继承问题。 多继承的不足之处：造成代码浪费，引发继承的多义性（即多个父类中可能含有几个命名相同的方法或属性，调用时就不知道使用的是来自哪里） 2）接口是抽象类的抽象，接口的方法都是抽象方法，默认都是public abstract类型。 3）接口的成员变量默认都是常量，被public final static 修饰。 4）接口没有构造器，不能被实例化。 5）接口可以继承多个接口，一个类也可以实现多个接口，达到解决多继承的目的。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记(基础篇)—数组模拟实现栈]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E2%80%94%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%A0%88.html</url>
    <content type="text"><![CDATA[栈的概念 先进后出策略(LIFO) 是一种基本数据结构 栈的分类有两种：1.静态栈（数组实现） 2.动态栈（链表实现） 栈的模型图如下： 需求分析在编写代码之前，我习惯先对要实现的程序进行需求分析，比如用什么数据结构存储数据，需要实现哪些基本的功能等。这次是通过数组模拟实现栈，所以是一个==静态栈==，但是我在栈满时通过arraycopy函数自动扩容，后面会细说。我们要实现的功能至少应该包含以下功能： public class Stack { private int[] array;//模拟栈 private int length = 0;//栈总长度 private int size = 0;//栈存在元素个数 public Stack() { this(10); } public Stack(int length) { array = new int[length]; this.length = length; } //入栈 public void push(int num) {} //出栈 public int pop() {} //栈是否为空 public boolean isEmpty() {} //栈是否已满,已满则每次扩容5个单位 public boolean isFull() {} //清除栈所有元素 public void removeAll() {} //获取栈内存在元素个数 public int getSize() {} //获取栈的总长度 public int getLength() {} } 具体实现 入栈push()首先判断当前栈是否已满，如果已满则扩容；此时栈内存在元素size增加1。 //入栈 public void push(int num) { isFull(); array[length-1-size] = num; size++; } 出栈pop()判断当前栈是否为空，为空则返回0；不为空，将数组中最靠近下标0的非0元素置0；此时栈内元素size减1，并返回出栈的值； //出栈 public int pop() { if(isEmpty()) { return 0; } int result = 0; for (int i = 0; i &lt; array.length; i++) { if (array[i]==0) { continue; } result = array[i]; array[i] = 0; size--; break; } return result; } 栈是否为空isEmpty() //栈是否为空 public boolean isEmpty() { if(size==0) { System.out.println("栈为空！"); return true; } return false; } 栈是否已满,已满则每次扩容5个单位isFull()如果栈内存在的元素个数等于数组长度，则表示栈已满；通过new一个新的更大的数组，调用arraycopy方法将b的引用赋给array，并且数组的长度也要加长。arraycopy()的参数含义如下： /** * 参数含义 * @param src 原数组对象的引用 * @param srcPos 原数组要拷贝的数据的原始位置 * @param dest 目标数组对象的引用 * @param destPos 目标数组要拷贝的数据的原始位置 * @param length 原数组要拷贝的长度 */ public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); //栈是否已满,已满则每次扩容5个单位 public boolean isFull() { if (size==length) { //System.out.println("当前栈已满，扩容5个单位。"); int[] b = new int[length+5]; System.arraycopy(array, 0, b, 5, length); array = b; this.length += 5; return true; } return false; } 清除栈所有元素removeAll()清除所有元素就是遍历一遍数组，将全部元素的值置0； //清除栈所有元素 public void removeAll() { for (int i = 0; i &lt; array.length; i++) { if (array[i]!=0) { array[i] = 0; size--; } } } 获取栈内存在元素个数getSize() //获取栈内存在元素个数 public int getSize() { return size; } 获取栈的总长度getLength() //获取栈的总长度 public int getLength() { return length; } 测试public class StackTest { public static void main(String[] args) { //创建一个默认长度为10的栈 Stack stack = new Stack(2); //入栈 stack.push(10); stack.push(9); stack.push(8); System.out.println("当前栈元素个数:"+stack.getSize()); System.out.println("当前栈的总长度:"+stack.getLength()); stack.printStack(); //出栈 int p = stack.pop(); System.out.println("当前出栈元素的值:"+p); System.out.println("当前栈元素个数:"+stack.getSize()); System.out.println("当前栈的总长度:"+stack.getLength()); stack.printStack(); //清空栈 stack.removeAll(); //stack.isEmpty(); int p2 = stack.pop(); System.out.println("当前出栈元素的值:"+p2); System.out.println("当前栈元素个数:"+stack.getSize()); System.out.println("当前栈的总长度:"+stack.getLength()); } } 测试结果： 当前栈元素个数:3 当前栈的总长度:7 当前栈情况:8 9 10 当前出栈元素的值:8 当前栈元素个数:2 当前栈的总长度:7 当前栈情况:9 10 栈为空！ 当前出栈元素的值:0 当前栈元素个数:0 当前栈的总长度:7 欢迎访问我的个人网站www.chlinlearn.cn到这里就要结束了，后续如果有时间也会出一篇链表实现栈的文章，欢迎来访问我的个人网站，最新文章都会首先在那里发布哦^^]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现DFA模拟程序]]></title>
    <url>%2Fpython%E5%AE%9E%E7%8E%B0dfa%E6%A8%A1%E6%8B%9F%E7%A8%8B%E5%BA%8F.html</url>
    <content type="text"><![CDATA[DFA（确定的有穷自动机）一个确定的有穷自动机M是一个五元组： M=(K，∑，f，S，Z) K是一个有穷集，它的每个元素称为一个状态。 ∑是一个有穷字母表，它的每一个元素称为一个输入符号，所以也陈∑为输入符号表。 f是转换函数，是Kx∑-&gt;K上的映象。 S∈K，是唯一的一个初态。 Z∈K，是一个终态集，终态也称可接受状态或结束状态。 实例代码 实现文法 G[S]: S->aU|bV U->bV|aQ Q->aQ|bQ 状态图 代码实现 -*- coding: utf-8 -*- # #@author: chlinlearn #@createTime: 2019/4/13 14:12 #@fileName: DFA class DFA(): def __init__(self): #状态集 self.listEdge = [] #初态 self.S = [] #终态 self.Z = [] #判断是否是终态集 def isZ(self,ch): for i in range(0,len(self.Z)) : if self.Z[0] == ch or self.Z[1] == ch: return True else: return False #输入 def input(self): self.S = input("请输入开始符：") self.Z = input("请输入终态集(终集符组成的一个字符串)：") self.Z = self.Z.split(",") print("请输入正规文法以exit结尾：") print("example:S,aZ") while(True): list = [] inStr = input() if inStr=='exit': break inStr = inStr.split(',') # 读取第一个状态集 s = inStr[0] for i in range(0,len(inStr[1])): #ch,ns if len(inStr[1])==2: c = inStr[1][0] n = inStr[1][1] list = [s,c,n] self.listEdge.append(list) elif len(inStr[1])==1: c = inStr[1][0] list = [s, c, self.Z[0]] self.listEdge.append(list) #转换函数 def isNextState(self,s,ch): for i in range(0,len(self.listEdge)): if s == self.listEdge[i][0] and ch == self.listEdge[i][1]: return self.listEdge[i][2] return def judgeDFA(self): print("请输入要判断的字符串:") while(True): #获取字母表 str = input() if '#' in str : print("程序已退出，欢迎下次使用!") return temp = self.S[0] for i in range(0,len(str)): if str[i] is 'a': temp = self.isNextState(temp,'a') elif str[i] is 'b': temp = self.isNextState(temp, 'b') else: break if self.isZ(temp): print("此字符串“属于”该文法！") else: print("此字符串“不属于”该文法！") print("再次判断请输入字符串(退出程序输入#):") if __name__ == '__main__': DFA = DFA() DFA.input() DFA.judgeDFA() 总结这是我在课程中的一个实验，代码手写并且可运行，是参照一个java版的代码实现的，加上自己的理解和思路把它以python的形式实现。学习别人好的地方，当然也不能照搬别人，不然能够为己用的东西少之又少。通过不同的编程语言把整个思路在理一遍能够加深自己的理解，并且能够得到一样的运行结果，说明自己的理解是对的。最后也附上对应的java版代码，有需求的童鞋可以参考喔！欢迎访问我的个人网站www.chlinlearn.cn 附件java版DFA import java.util.ArrayList; import java.util.List; import java.util.Scanner; class edge { char PriorityState; char ch; char NextState; edge(char p,char c, char n){ PriorityState = p; ch = c; NextState = n; } @Override public String toString() { return "edge [PriorityState=" + PriorityState + ", ch=" + ch + ", NextState=" + NextState + "]"; } } /**DFA的构造*/ public class DFA { static List&lt;edge> listEdge = new ArrayList&lt;edge>();//状态集 //static HashMap&lt;edge, Character> mapEdge = new HashMap&lt;>(); static String S;//初态集 static String Z;//终态集 //flag is here static boolean judeZ(char ch){ for(int j=0; j&lt;Z.length(); j++){ if(Z.charAt(j)==ch) return true; } return false; } static void input() { Scanner in = new Scanner(System.in); String instr = null; String subStr[] = null; System.out.println("请输入开始符："); S = in.next(); System.out.println("请输入终态集(终集符组成的一个字符串)："); Z = in.next(); System.out.println("请输入正规文法以end结尾(形式如下图)："); System.out.println("----------"); System.out.println("| S-aU |"); System.out.println("| S-bV |"); System.out.println("| U-bV |"); System.out.println("| .... |"); System.out.println("| end |"); System.out.println("----------"); while(in.hasNext()){ instr = in.next(); if("end".equals(instr)) break; subStr = instr.split("-|\\|");//连字符 System.out.println("subStr:"+subStr); String s = subStr[0];//读取一行f(转换函数) System.out.println(s); for(int i=1; i&lt;subStr.length; i++){ edge e = null; System.out.println(subStr[1]); if(subStr[i].length()==2){ char c = subStr[i].charAt(0);//字母表 char n = subStr[i].charAt(1);//状态集 listEdge.add(new edge(s.charAt(0),c,n));//f(S,a)=U } if(subStr[i].length()==1){ char c = subStr[i].charAt(0); listEdge.add(new edge(s.charAt(0),c,Z.charAt(0))); } } } } static char judeNextState(char s,char ch){ for(int i=0; i&lt;listEdge.size(); i++){ if(s==listEdge.get(i).PriorityState &amp;&amp; ch==listEdge.get(i).ch){ return listEdge.get(i).NextState; } } return '0'; } static void judeDFA(){ Scanner in = new Scanner(System.in); System.out.println("请输入要判断的字符串:"); while(in.hasNext()){ String str = in.next(); if(str.equals("#")){ System.out.println("程序已退出，欢迎下次使用!"); return; } char temp = S.charAt(0); int i=0; //System.out.println(temp+" "+mapEdge.get(e)); for(; i&lt;str.length(); i++){ //System.out.println("temp="+temp); if(str.charAt(i)=='a'){ temp = judeNextState(temp, 'a'); } else if(str.charAt(i)=='b'){ temp = judeNextState(temp, 'b'); } else break; } //flag is here if(i>=str.length() &amp;&amp; judeZ(temp)) System.out.println("此字符串“属于”该文法！"); else System.out.println("此字符串“不属于”该文法！"); System.out.println("再次判断请输入字符串(退出程序输入#):"); } } /*main*/ public static void main(String[] args) { // TODO Auto-generated method stub DFA.input(); DFA.judeDFA(); } }]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>DFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新篇章]]></title>
    <url>%2F%E6%96%B0%E7%AF%87%E7%AB%A0.html</url>
    <content type="text"><![CDATA[hi,大家好！准备了好久，下了很大的决心，终于可以开始更博啦！]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
</search>
